<html><head><title>Function catalog (4969 total)</title>
	<link rel="stylesheet" href="http://tablesorter.com/themes/blue/style.css" type="text/css" media="print, projection, screen"/> 
 <script type="text/javascript" src="http://code.jquery.com/jquery-2.1.4.min.js"></script> 
 <script type="text/javascript" src="http://tablesorter.com/__jquery.tablesorter.min.js"></script> 
 <script type="text/javascript">	$(function() { 
	$("#myTable1882165300").tablesorter({widgets: ['zebra']}); 
 }); </script> </head>
<body style="margin:70px"><h1>Function catalog (4969 total)</h1>
<table style='background-color: #FFF;' id="myTable1882165300" class="tablesorter" border="0" cellspacing="1" cellpadding="0" style="font-size:11pt"><thead><tr><th style='padding-right:12px;font-size:11pt'>Domain</th><th style='padding-right:12px;font-size:11pt'>ShortName</th><th style='padding-right:12px;font-size:11pt'>Name</th><th style='padding-right:12px;font-size:11pt'>ReturnType</th><th style='padding-right:12px;font-size:11pt'>Param1</th><th style='padding-right:12px;font-size:11pt'>Param2</th><th style='padding-right:12px;font-size:11pt'>Param3</th></tr></thead>
<tbody>
<tr><td></td><td>constant.Int.0</td><td>constant.Int.0</td><td>Int</td><td></td><td></td><td></td></tr>
<tr><td></td><td>constant.Int.1</td><td>constant.Int.1</td><td>Int</td><td></td><td></td><td></td></tr>
<tr><td></td><td>if</td><td>if</td><td>Any</td><td>condition:java.lang.Boolean</td><td>trueClause:Any</td><td>falseClause:Any</td></tr>
<tr><td>arithmetics</td><td>inverse</td><td>core.Solving.SpecialFunctions.inverse(num: Double): Double</td><td>Double</td><td>num:Double</td><td></td><td></td></tr>
<tr><td>arithmetics, math</td><td>squared</td><td>core.Solving.SpecialFunctions.squared(num: Double): Double</td><td>Double</td><td>num:Double</td><td></td><td></td></tr>
<tr><td>arithmetics, math</td><td>$div</td><td>scala.Double.$div(x: Byte): Double</td><td>Double</td><td>Double:Double</td><td>x:Byte</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$div</td><td>scala.Double.$div(x: Char): Double</td><td>Double</td><td>Double:Double</td><td>x:Char</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$div</td><td>scala.Double.$div(x: Double): Double</td><td>Double</td><td>Double:Double</td><td>x:Double</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$div</td><td>scala.Double.$div(x: Int): Double</td><td>Double</td><td>Double:Double</td><td>x:Int</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$div</td><td>scala.Double.$div(x: Long): Double</td><td>Double</td><td>Double:Double</td><td>x:Long</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$minus</td><td>scala.Double.$minus(x: Byte): Double</td><td>Double</td><td>Double:Double</td><td>x:Byte</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$minus</td><td>scala.Double.$minus(x: Char): Double</td><td>Double</td><td>Double:Double</td><td>x:Char</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$minus</td><td>scala.Double.$minus(x: Double): Double</td><td>Double</td><td>Double:Double</td><td>x:Double</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$minus</td><td>scala.Double.$minus(x: Int): Double</td><td>Double</td><td>Double:Double</td><td>x:Int</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$minus</td><td>scala.Double.$minus(x: Long): Double</td><td>Double</td><td>Double:Double</td><td>x:Long</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$plus</td><td>scala.Double.$plus(x: Byte): Double</td><td>Double</td><td>Double:Double</td><td>x:Byte</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$plus</td><td>scala.Double.$plus(x: Char): Double</td><td>Double</td><td>Double:Double</td><td>x:Char</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$plus</td><td>scala.Double.$plus(x: Double): Double</td><td>Double</td><td>Double:Double</td><td>x:Double</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$plus</td><td>scala.Double.$plus(x: Int): Double</td><td>Double</td><td>Double:Double</td><td>x:Int</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$plus</td><td>scala.Double.$plus(x: Long): Double</td><td>Double</td><td>Double:Double</td><td>x:Long</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$plus</td><td>scala.Double.$plus(x: String): String</td><td>String</td><td>Double:Double</td><td>x:String</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$times</td><td>scala.Double.$times(x: Byte): Double</td><td>Double</td><td>Double:Double</td><td>x:Byte</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$times</td><td>scala.Double.$times(x: Double): Double</td><td>Double</td><td>Double:Double</td><td>x:Double</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$times</td><td>scala.Double.$times(x: Int): Double</td><td>Double</td><td>Double:Double</td><td>x:Int</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$times</td><td>scala.Double.$times(x: Long): Double</td><td>Double</td><td>Double:Double</td><td>x:Long</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$minus</td><td>scala.Int.$minus(x: Byte): Int</td><td>Int</td><td>Int:Int</td><td>x:Byte</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$minus</td><td>scala.Int.$minus(x: Char): Int</td><td>Int</td><td>Int:Int</td><td>x:Char</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$minus</td><td>scala.Int.$minus(x: Double): Double</td><td>Double</td><td>Int:Int</td><td>x:Double</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$minus</td><td>scala.Int.$minus(x: Int): Int</td><td>Int</td><td>Int:Int</td><td>x:Int</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$minus</td><td>scala.Int.$minus(x: Long): Long</td><td>Long</td><td>Int:Int</td><td>x:Long</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$plus</td><td>scala.Int.$plus(x: Byte): Int</td><td>Int</td><td>Int:Int</td><td>x:Byte</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$plus</td><td>scala.Int.$plus(x: Char): Int</td><td>Int</td><td>Int:Int</td><td>x:Char</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$plus</td><td>scala.Int.$plus(x: Double): Double</td><td>Double</td><td>Int:Int</td><td>x:Double</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$plus</td><td>scala.Int.$plus(x: Int): Int</td><td>Int</td><td>Int:Int</td><td>x:Int</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$plus</td><td>scala.Int.$plus(x: Long): Long</td><td>Long</td><td>Int:Int</td><td>x:Long</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$plus</td><td>scala.Int.$plus(x: String): String</td><td>String</td><td>Int:Int</td><td>x:String</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$times</td><td>scala.Int.$times(x: Byte): Int</td><td>Int</td><td>Int:Int</td><td>x:Byte</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$times</td><td>scala.Int.$times(x: Double): Double</td><td>Double</td><td>Int:Int</td><td>x:Double</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$times</td><td>scala.Int.$times(x: Int): Int</td><td>Int</td><td>Int:Int</td><td>x:Int</td><td></td></tr>
<tr><td>arithmetics, math</td><td>$times</td><td>scala.Int.$times(x: Long): Long</td><td>Long</td><td>Int:Int</td><td>x:Long</td><td></td></tr>
<tr><td>bitwise</td><td>$amp</td><td>scala.Boolean.$amp(x: Boolean): Boolean</td><td>Boolean</td><td>Boolean:Boolean</td><td>x:Boolean</td><td></td></tr>
<tr><td>bitwise</td><td>$bar</td><td>scala.Boolean.$bar(x: Boolean): Boolean</td><td>Boolean</td><td>Boolean:Boolean</td><td>x:Boolean</td><td></td></tr>
<tr><td>bitwise</td><td>$up</td><td>scala.Boolean.$up(x: Boolean): Boolean</td><td>Boolean</td><td>Boolean:Boolean</td><td>x:Boolean</td><td></td></tr>
<tr><td>bitwise</td><td>$amp</td><td>scala.Byte.$amp(x: Byte): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Byte</td><td></td></tr>
<tr><td>bitwise</td><td>$amp</td><td>scala.Byte.$amp(x: Char): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Char</td><td></td></tr>
<tr><td>bitwise</td><td>$amp</td><td>scala.Byte.$amp(x: Int): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Int</td><td></td></tr>
<tr><td>bitwise</td><td>$amp</td><td>scala.Byte.$amp(x: Long): Long</td><td>Long</td><td>Byte:Byte</td><td>x:Long</td><td></td></tr>
<tr><td>bitwise</td><td>$bar</td><td>scala.Byte.$bar(x: Byte): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Byte</td><td></td></tr>
<tr><td>bitwise</td><td>$bar</td><td>scala.Byte.$bar(x: Char): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Char</td><td></td></tr>
<tr><td>bitwise</td><td>$bar</td><td>scala.Byte.$bar(x: Int): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Int</td><td></td></tr>
<tr><td>bitwise</td><td>$bar</td><td>scala.Byte.$bar(x: Long): Long</td><td>Long</td><td>Byte:Byte</td><td>x:Long</td><td></td></tr>
<tr><td>bitwise</td><td>$up</td><td>scala.Byte.$up(x: Byte): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Byte</td><td></td></tr>
<tr><td>bitwise</td><td>$up</td><td>scala.Byte.$up(x: Char): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Char</td><td></td></tr>
<tr><td>bitwise</td><td>$up</td><td>scala.Byte.$up(x: Int): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Int</td><td></td></tr>
<tr><td>bitwise</td><td>$up</td><td>scala.Byte.$up(x: Long): Long</td><td>Long</td><td>Byte:Byte</td><td>x:Long</td><td></td></tr>
<tr><td>bitwise</td><td>$amp</td><td>scala.Char.$amp(x: Byte): Int</td><td>Int</td><td>Char:Char</td><td>x:Byte</td><td></td></tr>
<tr><td>bitwise</td><td>$amp</td><td>scala.Char.$amp(x: Char): Int</td><td>Int</td><td>Char:Char</td><td>x:Char</td><td></td></tr>
<tr><td>bitwise</td><td>$amp</td><td>scala.Char.$amp(x: Int): Int</td><td>Int</td><td>Char:Char</td><td>x:Int</td><td></td></tr>
<tr><td>bitwise</td><td>$amp</td><td>scala.Char.$amp(x: Long): Long</td><td>Long</td><td>Char:Char</td><td>x:Long</td><td></td></tr>
<tr><td>bitwise</td><td>$bar</td><td>scala.Char.$bar(x: Byte): Int</td><td>Int</td><td>Char:Char</td><td>x:Byte</td><td></td></tr>
<tr><td>bitwise</td><td>$bar</td><td>scala.Char.$bar(x: Char): Int</td><td>Int</td><td>Char:Char</td><td>x:Char</td><td></td></tr>
<tr><td>bitwise</td><td>$bar</td><td>scala.Char.$bar(x: Int): Int</td><td>Int</td><td>Char:Char</td><td>x:Int</td><td></td></tr>
<tr><td>bitwise</td><td>$bar</td><td>scala.Char.$bar(x: Long): Long</td><td>Long</td><td>Char:Char</td><td>x:Long</td><td></td></tr>
<tr><td>bitwise</td><td>$up</td><td>scala.Char.$up(x: Byte): Int</td><td>Int</td><td>Char:Char</td><td>x:Byte</td><td></td></tr>
<tr><td>bitwise</td><td>$up</td><td>scala.Char.$up(x: Char): Int</td><td>Int</td><td>Char:Char</td><td>x:Char</td><td></td></tr>
<tr><td>bitwise</td><td>$up</td><td>scala.Char.$up(x: Int): Int</td><td>Int</td><td>Char:Char</td><td>x:Int</td><td></td></tr>
<tr><td>bitwise</td><td>$up</td><td>scala.Char.$up(x: Long): Long</td><td>Long</td><td>Char:Char</td><td>x:Long</td><td></td></tr>
<tr><td>bitwise, collections</td><td>$amp$tilde</td><td>scala.collection.GenSetLike.$amp$tilde(that: scala.collection.GenSet[A]): Repr</td><td>Repr</td><td>GenSetLike:scala.collection.GenSetLike[A,Repr]</td><td>that:scala.collection.GenSet[A]</td><td></td></tr>
<tr><td>bitwise, collections</td><td>$amp</td><td>scala.collection.GenSetLike.$amp(that: scala.collection.GenSet[A]): Repr</td><td>Repr</td><td>GenSetLike:scala.collection.GenSetLike[A,Repr]</td><td>that:scala.collection.GenSet[A]</td><td></td></tr>
<tr><td>bitwise, collections</td><td>$bar</td><td>scala.collection.GenSetLike.$bar(that: scala.collection.GenSet[A]): Repr</td><td>Repr</td><td>GenSetLike:scala.collection.GenSetLike[A,Repr]</td><td>that:scala.collection.GenSet[A]</td><td></td></tr>
<tr><td>bitwise, math</td><td>$amp</td><td>scala.Int.$amp(x: Byte): Int</td><td>Int</td><td>Int:Int</td><td>x:Byte</td><td></td></tr>
<tr><td>bitwise, math</td><td>$amp</td><td>scala.Int.$amp(x: Char): Int</td><td>Int</td><td>Int:Int</td><td>x:Char</td><td></td></tr>
<tr><td>bitwise, math</td><td>$amp</td><td>scala.Int.$amp(x: Int): Int</td><td>Int</td><td>Int:Int</td><td>x:Int</td><td></td></tr>
<tr><td>bitwise, math</td><td>$amp</td><td>scala.Int.$amp(x: Long): Long</td><td>Long</td><td>Int:Int</td><td>x:Long</td><td></td></tr>
<tr><td>bitwise, math</td><td>$bar</td><td>scala.Int.$bar(x: Byte): Int</td><td>Int</td><td>Int:Int</td><td>x:Byte</td><td></td></tr>
<tr><td>bitwise, math</td><td>$bar</td><td>scala.Int.$bar(x: Char): Int</td><td>Int</td><td>Int:Int</td><td>x:Char</td><td></td></tr>
<tr><td>bitwise, math</td><td>$bar</td><td>scala.Int.$bar(x: Int): Int</td><td>Int</td><td>Int:Int</td><td>x:Int</td><td></td></tr>
<tr><td>bitwise, math</td><td>$bar</td><td>scala.Int.$bar(x: Long): Long</td><td>Long</td><td>Int:Int</td><td>x:Long</td><td></td></tr>
<tr><td>bitwise, math</td><td>$up</td><td>scala.Int.$up(x: Byte): Int</td><td>Int</td><td>Int:Int</td><td>x:Byte</td><td></td></tr>
<tr><td>bitwise, math</td><td>$up</td><td>scala.Int.$up(x: Char): Int</td><td>Int</td><td>Int:Int</td><td>x:Char</td><td></td></tr>
<tr><td>bitwise, math</td><td>$up</td><td>scala.Int.$up(x: Int): Int</td><td>Int</td><td>Int:Int</td><td>x:Int</td><td></td></tr>
<tr><td>bitwise, math</td><td>$up</td><td>scala.Int.$up(x: Long): Long</td><td>Long</td><td>Int:Int</td><td>x:Long</td><td></td></tr>
<tr><td>booleanOperators</td><td>$bang$eq</td><td>scala.Any.$bang$eq(x$1: Any): Boolean</td><td>Boolean</td><td>Any:Any</td><td>x$1:Any</td><td></td></tr>
<tr><td>booleanOperators</td><td>$eq$eq</td><td>scala.Any.$eq$eq(x$1: Any): Boolean</td><td>Boolean</td><td>Any:Any</td><td>x$1:Any</td><td></td></tr>
<tr><td>booleanOperators</td><td>unary_$bang</td><td>scala.Boolean.unary_$bang: Boolean</td><td>Boolean</td><td>Boolean:Boolean</td><td></td><td></td></tr>
<tr><td>booleanOperators</td><td>$greater$greater$greater</td><td>scala.Byte.$greater$greater$greater(x: Int): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Int</td><td></td></tr>
<tr><td>booleanOperators</td><td>$greater$greater$greater</td><td>scala.Byte.$greater$greater$greater(x: Long): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Long</td><td></td></tr>
<tr><td>booleanOperators</td><td>$greater$greater</td><td>scala.Byte.$greater$greater(x: Int): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Int</td><td></td></tr>
<tr><td>booleanOperators</td><td>$greater$greater</td><td>scala.Byte.$greater$greater(x: Long): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Long</td><td></td></tr>
<tr><td>booleanOperators</td><td>$greater</td><td>scala.Byte.$greater(x: Byte): Boolean</td><td>Boolean</td><td>Byte:Byte</td><td>x:Byte</td><td></td></tr>
<tr><td>booleanOperators</td><td>$greater</td><td>scala.Byte.$greater(x: Char): Boolean</td><td>Boolean</td><td>Byte:Byte</td><td>x:Char</td><td></td></tr>
<tr><td>booleanOperators</td><td>$greater</td><td>scala.Byte.$greater(x: Double): Boolean</td><td>Boolean</td><td>Byte:Byte</td><td>x:Double</td><td></td></tr>
<tr><td>booleanOperators</td><td>$greater</td><td>scala.Byte.$greater(x: Int): Boolean</td><td>Boolean</td><td>Byte:Byte</td><td>x:Int</td><td></td></tr>
<tr><td>booleanOperators</td><td>$greater</td><td>scala.Byte.$greater(x: Long): Boolean</td><td>Boolean</td><td>Byte:Byte</td><td>x:Long</td><td></td></tr>
<tr><td>booleanOperators</td><td>$greater$greater$greater</td><td>scala.Char.$greater$greater$greater(x: Int): Int</td><td>Int</td><td>Char:Char</td><td>x:Int</td><td></td></tr>
<tr><td>booleanOperators</td><td>$greater$greater$greater</td><td>scala.Char.$greater$greater$greater(x: Long): Int</td><td>Int</td><td>Char:Char</td><td>x:Long</td><td></td></tr>
<tr><td>booleanOperators</td><td>$greater$greater</td><td>scala.Char.$greater$greater(x: Int): Int</td><td>Int</td><td>Char:Char</td><td>x:Int</td><td></td></tr>
<tr><td>booleanOperators</td><td>$greater$greater</td><td>scala.Char.$greater$greater(x: Long): Int</td><td>Int</td><td>Char:Char</td><td>x:Long</td><td></td></tr>
<tr><td>booleanOperators</td><td>$greater</td><td>scala.Char.$greater(x: Byte): Boolean</td><td>Boolean</td><td>Char:Char</td><td>x:Byte</td><td></td></tr>
<tr><td>booleanOperators</td><td>$greater</td><td>scala.Char.$greater(x: Char): Boolean</td><td>Boolean</td><td>Char:Char</td><td>x:Char</td><td></td></tr>
<tr><td>booleanOperators</td><td>$greater</td><td>scala.Char.$greater(x: Double): Boolean</td><td>Boolean</td><td>Char:Char</td><td>x:Double</td><td></td></tr>
<tr><td>booleanOperators</td><td>$greater</td><td>scala.Char.$greater(x: Int): Boolean</td><td>Boolean</td><td>Char:Char</td><td>x:Int</td><td></td></tr>
<tr><td>booleanOperators</td><td>$greater</td><td>scala.Char.$greater(x: Long): Boolean</td><td>Boolean</td><td>Char:Char</td><td>x:Long</td><td></td></tr>
<tr><td>booleanOperators, bitwise</td><td>$amp$amp</td><td>scala.Boolean.$amp$amp(x: Boolean): Boolean</td><td>Boolean</td><td>Boolean:Boolean</td><td>x:Boolean</td><td></td></tr>
<tr><td>booleanOperators, bitwise</td><td>$bar$bar</td><td>scala.Boolean.$bar$bar(x: Boolean): Boolean</td><td>Boolean</td><td>Boolean:Boolean</td><td>x:Boolean</td><td></td></tr>
<tr><td>booleanOperators, math</td><td>$greater</td><td>scala.Double.$greater(x: Byte): Boolean</td><td>Boolean</td><td>Double:Double</td><td>x:Byte</td><td></td></tr>
<tr><td>booleanOperators, math</td><td>$greater</td><td>scala.Double.$greater(x: Char): Boolean</td><td>Boolean</td><td>Double:Double</td><td>x:Char</td><td></td></tr>
<tr><td>booleanOperators, math</td><td>$greater</td><td>scala.Double.$greater(x: Double): Boolean</td><td>Boolean</td><td>Double:Double</td><td>x:Double</td><td></td></tr>
<tr><td>booleanOperators, math</td><td>$greater</td><td>scala.Double.$greater(x: Int): Boolean</td><td>Boolean</td><td>Double:Double</td><td>x:Int</td><td></td></tr>
<tr><td>booleanOperators, math</td><td>$greater</td><td>scala.Double.$greater(x: Long): Boolean</td><td>Boolean</td><td>Double:Double</td><td>x:Long</td><td></td></tr>
<tr><td>booleanOperators, math</td><td>$greater$greater$greater</td><td>scala.Int.$greater$greater$greater(x: Int): Int</td><td>Int</td><td>Int:Int</td><td>x:Int</td><td></td></tr>
<tr><td>booleanOperators, math</td><td>$greater$greater$greater</td><td>scala.Int.$greater$greater$greater(x: Long): Int</td><td>Int</td><td>Int:Int</td><td>x:Long</td><td></td></tr>
<tr><td>booleanOperators, math</td><td>$greater$greater</td><td>scala.Int.$greater$greater(x: Int): Int</td><td>Int</td><td>Int:Int</td><td>x:Int</td><td></td></tr>
<tr><td>booleanOperators, math</td><td>$greater$greater</td><td>scala.Int.$greater$greater(x: Long): Int</td><td>Int</td><td>Int:Int</td><td>x:Long</td><td></td></tr>
<tr><td>booleanOperators, math</td><td>$greater</td><td>scala.Int.$greater(x: Byte): Boolean</td><td>Boolean</td><td>Int:Int</td><td>x:Byte</td><td></td></tr>
<tr><td>booleanOperators, math</td><td>$greater</td><td>scala.Int.$greater(x: Char): Boolean</td><td>Boolean</td><td>Int:Int</td><td>x:Char</td><td></td></tr>
<tr><td>booleanOperators, math</td><td>$greater</td><td>scala.Int.$greater(x: Double): Boolean</td><td>Boolean</td><td>Int:Int</td><td>x:Double</td><td></td></tr>
<tr><td>booleanOperators, math</td><td>$greater</td><td>scala.Int.$greater(x: Int): Boolean</td><td>Boolean</td><td>Int:Int</td><td>x:Int</td><td></td></tr>
<tr><td>booleanOperators, math</td><td>$greater</td><td>scala.Int.$greater(x: Long): Boolean</td><td>Boolean</td><td>Int:Int</td><td>x:Long</td><td></td></tr>
<tr><td>collections</td><td>centroid</td><td>core.Solving.GeoFunctions.centroid(i: scala.collection.GenTraversableOnce[core.datastructures.LatLong]): core.datastructures.LatLong</td><td>core.datastructures.LatLong</td><td>i:scala.collection.GenTraversableOnce[core.datastructures.LatLong]</td><td></td><td></td></tr>
<tr><td>collections</td><td>deviation</td><td>core.Solving.GeoFunctions.deviation(coords: scala.collection.GenTraversableOnce[core.datastructures.LatLong]): Double</td><td>Double</td><td>coords:scala.collection.GenTraversableOnce[core.datastructures.LatLong]</td><td></td><td></td></tr>
<tr><td>collections</td><td>flatten</td><td>core.Solving.ImplicitFreeExtensions.flatten[A](a: Iterable[Iterable[A]]): Iterable[A]</td><td>Iterable[A]</td><td>a:Iterable[Iterable[A]]</td><td></td><td></td></tr>
<tr><td>collections</td><td>getOrElse</td><td>core.Solving.ImplicitFreeExtensions.getOrElse[A,B,B1&gt;:B](m: scala.collection.GenMap[A,B],key: A,default: B1): B1</td><td>B1</td><td>m:scala.collection.GenMap[A,B]</td><td>key:A</td><td>default:B1</td></tr>
<tr><td>collections</td><td>zipWithIndex</td><td>core.Solving.ImplicitFreeExtensions.zipWithIndex[A](i: scala.collection.GenIterableLike[A,scala.collection.TraversableOnce[A]]): scala.collection.TraversableOnce[(A,Int)]</td><td>scala.collection.TraversableOnce[(A, Int)]</td><td>i:scala.collection.GenIterableLike[A,scala.collection.TraversableOnce[A]]</td><td></td><td></td></tr>
<tr><td>collections</td><td>zip</td><td>core.Solving.ImplicitFreeExtensions.zip[T,U](i: scala.collection.GenIterable[T],j: scala.collection.GenIterable[U]): scala.collection.GenIterable[(T,U)]</td><td>scala.collection.GenIterable[(T, U)]</td><td>i:scala.collection.GenIterable[T]</td><td>j:scala.collection.GenIterable[U]</td><td></td></tr>
<tr><td>collections</td><td>max</td><td>core.Solving.ImplicitFreeExtensionsBigInt.max[T](i: Seq[BigInt]): BigInt</td><td>BigInt</td><td>i:Seq[BigInt]</td><td></td><td></td></tr>
<tr><td>collections</td><td>min</td><td>core.Solving.ImplicitFreeExtensionsBigInt.min[T](i: Seq[BigInt]): BigInt</td><td>BigInt</td><td>i:Seq[BigInt]</td><td></td><td></td></tr>
<tr><td>collections</td><td>product</td><td>core.Solving.ImplicitFreeExtensionsBigInt.product(i: scala.collection.GenTraversableOnce[BigInt]): BigInt</td><td>BigInt</td><td>i:scala.collection.GenTraversableOnce[BigInt]</td><td></td><td></td></tr>
<tr><td>collections</td><td>sorted</td><td>core.Solving.ImplicitFreeExtensionsBigInt.sorted(i: Seq[BigInt]): Seq[BigInt]</td><td>Seq[BigInt]</td><td>i:Seq[BigInt]</td><td></td><td></td></tr>
<tr><td>collections</td><td>sum</td><td>core.Solving.ImplicitFreeExtensionsBigInt.sum(i: scala.collection.GenTraversableOnce[BigInt]): BigInt</td><td>BigInt</td><td>i:scala.collection.GenTraversableOnce[BigInt]</td><td></td><td></td></tr>
<tr><td>collections</td><td>max</td><td>core.Solving.ImplicitFreeExtensionsChar.max[T](i: Seq[Char]): Char</td><td>Char</td><td>i:Seq[Char]</td><td></td><td></td></tr>
<tr><td>collections</td><td>min</td><td>core.Solving.ImplicitFreeExtensionsChar.min[T](i: Seq[Char]): Char</td><td>Char</td><td>i:Seq[Char]</td><td></td><td></td></tr>
<tr><td>collections</td><td>max</td><td>core.Solving.ImplicitFreeExtensionsDouble.max(i: Seq[Double]): Double</td><td>Double</td><td>i:Seq[Double]</td><td></td><td></td></tr>
<tr><td>collections</td><td>min</td><td>core.Solving.ImplicitFreeExtensionsDouble.min(i: Seq[Double]): Double</td><td>Double</td><td>i:Seq[Double]</td><td></td><td></td></tr>
<tr><td>collections</td><td>product</td><td>core.Solving.ImplicitFreeExtensionsDouble.product(i: scala.collection.GenTraversableOnce[Double]): Double</td><td>Double</td><td>i:scala.collection.GenTraversableOnce[Double]</td><td></td><td></td></tr>
<tr><td>collections</td><td>sorted</td><td>core.Solving.ImplicitFreeExtensionsDouble.sorted(i: Seq[Double]): Seq[Double]</td><td>Seq[Double]</td><td>i:Seq[Double]</td><td></td><td></td></tr>
<tr><td>collections</td><td>sum</td><td>core.Solving.ImplicitFreeExtensionsDouble.sum(i: scala.collection.GenTraversableOnce[Double]): Double</td><td>Double</td><td>i:scala.collection.GenTraversableOnce[Double]</td><td></td><td></td></tr>
<tr><td>collections</td><td>max</td><td>core.Solving.ImplicitFreeExtensionsInt.max[T](i: scala.collection.GenTraversableOnce[Int]): Int</td><td>Int</td><td>i:scala.collection.GenTraversableOnce[Int]</td><td></td><td></td></tr>
<tr><td>collections</td><td>min</td><td>core.Solving.ImplicitFreeExtensionsInt.min[T](i: Seq[Int]): Int</td><td>Int</td><td>i:Seq[Int]</td><td></td><td></td></tr>
<tr><td>collections</td><td>product</td><td>core.Solving.ImplicitFreeExtensionsInt.product(i: scala.collection.GenTraversableOnce[Int]): Int</td><td>Int</td><td>i:scala.collection.GenTraversableOnce[Int]</td><td></td><td></td></tr>
<tr><td>collections</td><td>sorted</td><td>core.Solving.ImplicitFreeExtensionsInt.sorted(i: Seq[Int]): Seq[Int]</td><td>Seq[Int]</td><td>i:Seq[Int]</td><td></td><td></td></tr>
<tr><td>collections</td><td>sum</td><td>core.Solving.ImplicitFreeExtensionsInt.sum(i: scala.collection.GenTraversableOnce[Int]): Int</td><td>Int</td><td>i:scala.collection.GenTraversableOnce[Int]</td><td></td><td></td></tr>
<tr><td>collections</td><td>max</td><td>core.Solving.ImplicitFreeExtensionsString.max(i: Seq[String]): String</td><td>String</td><td>i:Seq[String]</td><td></td><td></td></tr>
<tr><td>collections</td><td>min</td><td>core.Solving.ImplicitFreeExtensionsString.min(i: Seq[String]): String</td><td>String</td><td>i:Seq[String]</td><td></td><td></td></tr>
<tr><td>collections</td><td>sorted</td><td>core.Solving.ImplicitFreeExtensionsString.sorted(i: String): String</td><td>String</td><td>i:String</td><td></td><td></td></tr>
<tr><td>collections</td><td>divDouble</td><td>core.Solving.SpecialFunctions.divDouble(i: scala.collection.GenTraversableOnce[Double],b: Double): scala.collection.GenTraversableOnce[Double]</td><td>scala.collection.GenTraversableOnce[Double]</td><td>i:scala.collection.GenTraversableOnce[Double]</td><td>b:Double</td><td></td></tr>
<tr><td>collections</td><td>divInt</td><td>core.Solving.SpecialFunctions.divInt(i: scala.collection.GenTraversableOnce[Int],b: Double): scala.collection.GenTraversableOnce[AnyVal]</td><td>scala.collection.GenTraversableOnce[AnyVal]</td><td>i:scala.collection.GenTraversableOnce[Int]</td><td>b:Double</td><td></td></tr>
<tr><td>collections</td><td>groupByKeyMaxValue</td><td>core.Solving.SpecialFunctions.groupByKeyMaxValue(values: scala.collection.GenTraversableOnce[(Any, Double)]): scala.collection.GenMap[Any,Double]</td><td>scala.collection.GenMap[Any,Double]</td><td>values:scala.collection.GenTraversableOnce[(Any, Double)]</td><td></td><td></td></tr>
<tr><td>collections</td><td>groupByKey</td><td>core.Solving.SpecialFunctions.groupByKey[T](values: scala.collection.GenTraversableOnce[(Any, T)]): scala.collection.GenMap[Any,scala.collection.GenIterable[(Any,T)]]</td><td>scala.collection.GenMap[Any,scala.collection.GenIterable[(Any, T)]]</td><td>values:scala.collection.GenTraversableOnce[(Any, T)]</td><td></td><td></td></tr>
<tr><td>collections</td><td>histogram</td><td>core.Solving.SpecialFunctions.histogram[T](values: scala.collection.GenTraversableOnce[T]): Seq[(T,Double)]</td><td>Seq[(T, Double)]</td><td>values:scala.collection.GenTraversableOnce[T]</td><td></td><td></td></tr>
<tr><td>collections</td><td>l1Norm</td><td>core.Solving.SpecialFunctions.l1Norm(i: scala.collection.GenTraversableOnce[Double]): Double</td><td>Double</td><td>i:scala.collection.GenTraversableOnce[Double]</td><td></td><td></td></tr>
<tr><td>collections</td><td>l1Normalize</td><td>core.Solving.SpecialFunctions.l1Normalize(i: scala.collection.GenTraversableOnce[Double]): scala.collection.GenTraversableOnce[Double]</td><td>scala.collection.GenTraversableOnce[Double]</td><td>i:scala.collection.GenTraversableOnce[Double]</td><td></td><td></td></tr>
<tr><td>collections</td><td>l2Norm</td><td>core.Solving.SpecialFunctions.l2Norm(i: scala.collection.GenTraversableOnce[Double]): Double</td><td>Double</td><td>i:scala.collection.GenTraversableOnce[Double]</td><td></td><td></td></tr>
<tr><td>collections</td><td>l2Normalize</td><td>core.Solving.SpecialFunctions.l2Normalize(i: scala.collection.GenTraversableOnce[Double]): scala.collection.GenTraversableOnce[Double]</td><td>scala.collection.GenTraversableOnce[Double]</td><td>i:scala.collection.GenTraversableOnce[Double]</td><td></td><td></td></tr>
<tr><td>collections</td><td>lInfNormalize</td><td>core.Solving.SpecialFunctions.lInfNormalize(i: scala.collection.GenTraversableOnce[Double]): scala.collection.GenTraversableOnce[Double]</td><td>scala.collection.GenTraversableOnce[Double]</td><td>i:scala.collection.GenTraversableOnce[Double]</td><td></td><td></td></tr>
<tr><td>collections</td><td>maxByKey</td><td>core.Solving.SpecialFunctions.maxByKey[T](raw: Iterable[(T, Double)]): scala.collection.immutable.Map[T,Double]</td><td>scala.collection.immutable.Map[T,Double]</td><td>raw:Iterable[(T, Double)]</td><td></td><td></td></tr>
<tr><td>collections</td><td>minusDouble</td><td>core.Solving.SpecialFunctions.minusDouble(i: scala.collection.GenTraversableOnce[Double],b: Double): scala.collection.GenTraversableOnce[Double]</td><td>scala.collection.GenTraversableOnce[Double]</td><td>i:scala.collection.GenTraversableOnce[Double]</td><td>b:Double</td><td></td></tr>
<tr><td>collections</td><td>minusInt</td><td>core.Solving.SpecialFunctions.minusInt(i: scala.collection.GenTraversableOnce[Int],b: Double): scala.collection.GenTraversableOnce[AnyVal]</td><td>scala.collection.GenTraversableOnce[AnyVal]</td><td>i:scala.collection.GenTraversableOnce[Int]</td><td>b:Double</td><td></td></tr>
<tr><td>collections</td><td>plusDouble</td><td>core.Solving.SpecialFunctions.plusDouble(i: scala.collection.GenTraversableOnce[Double],b: Double): scala.collection.GenTraversableOnce[Double]</td><td>scala.collection.GenTraversableOnce[Double]</td><td>i:scala.collection.GenTraversableOnce[Double]</td><td>b:Double</td><td></td></tr>
<tr><td>collections</td><td>plusInt</td><td>core.Solving.SpecialFunctions.plusInt(i: scala.collection.GenTraversableOnce[Int],b: Double): scala.collection.GenTraversableOnce[AnyVal]</td><td>scala.collection.GenTraversableOnce[AnyVal]</td><td>i:scala.collection.GenTraversableOnce[Int]</td><td>b:Double</td><td></td></tr>
<tr><td>collections</td><td>relativeShiftNormalize</td><td>core.Solving.SpecialFunctions.relativeShiftNormalize(i: scala.collection.GenTraversableOnce[Double]): scala.collection.GenTraversableOnce[Double]</td><td>scala.collection.GenTraversableOnce[Double]</td><td>i:scala.collection.GenTraversableOnce[Double]</td><td></td><td></td></tr>
<tr><td>collections</td><td>smallSubsets</td><td>core.Solving.SpecialFunctions.smallSubsets(i: scala.collection.GenTraversableOnce[Any]): scala.collection.immutable.Seq[List[Any]]</td><td>scala.collection.immutable.Seq[List[Any]]</td><td>i:scala.collection.GenTraversableOnce[Any]</td><td></td><td></td></tr>
<tr><td>collections</td><td>softMax</td><td>core.Solving.SpecialFunctions.softMax(seq: scala.collection.GenTraversableOnce[Double]): Double</td><td>Double</td><td>seq:scala.collection.GenTraversableOnce[Double]</td><td></td><td></td></tr>
<tr><td>collections</td><td>timesDouble</td><td>core.Solving.SpecialFunctions.timesDouble(i: scala.collection.GenTraversableOnce[Double],b: Double): scala.collection.GenTraversableOnce[Double]</td><td>scala.collection.GenTraversableOnce[Double]</td><td>i:scala.collection.GenTraversableOnce[Double]</td><td>b:Double</td><td></td></tr>
<tr><td>collections</td><td>timesInt</td><td>core.Solving.SpecialFunctions.timesInt(i: scala.collection.GenTraversableOnce[Int],b: Double): scala.collection.GenTraversableOnce[AnyVal]</td><td>scala.collection.GenTraversableOnce[AnyVal]</td><td>i:scala.collection.GenTraversableOnce[Int]</td><td>b:Double</td><td></td></tr>
<tr><td>collections</td><td>toDoubles</td><td>core.Solving.SpecialFunctions.toDoubles(i: scala.collection.GenTraversableOnce[Int]): scala.collection.GenTraversable[Double]</td><td>scala.collection.GenTraversable[Double]</td><td>i:scala.collection.GenTraversableOnce[Int]</td><td></td><td></td></tr>
<tr><td>collections</td><td>withoutMissingValueMinusOne</td><td>core.Solving.SpecialFunctions.withoutMissingValueMinusOne(i: scala.collection.GenTraversableOnce[Double]): scala.collection.GenSeq[Double]</td><td>scala.collection.GenSeq[Double]</td><td>i:scala.collection.GenTraversableOnce[Double]</td><td></td><td></td></tr>
<tr><td>collections</td><td>withoutMissingValueMinusOneInt</td><td>core.Solving.SpecialFunctions.withoutMissingValueMinusOneInt(i: scala.collection.GenTraversableOnce[Int]): scala.collection.GenSeq[Double]</td><td>scala.collection.GenSeq[Double]</td><td>i:scala.collection.GenTraversableOnce[Int]</td><td></td><td></td></tr>
<tr><td>collections</td><td>withoutNaNs</td><td>core.Solving.SpecialFunctions.withoutNaNs(i: scala.collection.GenTraversableOnce[Double]): scala.collection.GenSeq[Double]</td><td>scala.collection.GenSeq[Double]</td><td>i:scala.collection.GenTraversableOnce[Double]</td><td></td><td></td></tr>
<tr><td>collections</td><td>averageDouble</td><td>core.Solving.Statistics.averageDouble(i: scala.collection.GenTraversableOnce[Double]): Double</td><td>Double</td><td>i:scala.collection.GenTraversableOnce[Double]</td><td></td><td></td></tr>
<tr><td>collections</td><td>averageInt</td><td>core.Solving.Statistics.averageInt(i: scala.collection.GenTraversableOnce[Int]): Double</td><td>Double</td><td>i:scala.collection.GenTraversableOnce[Int]</td><td></td><td></td></tr>
<tr><td>collections</td><td>exponentialMovingAverage</td><td>core.Solving.Statistics.exponentialMovingAverage(i: scala.collection.GenTraversableOnce[Int]): Double</td><td>Double</td><td>i:scala.collection.GenTraversableOnce[Int]</td><td></td><td></td></tr>
<tr><td>collections</td><td>exponentialMovingAverageDouble</td><td>core.Solving.Statistics.exponentialMovingAverageDouble(i: scala.collection.GenTraversableOnce[Double]): Double</td><td>Double</td><td>i:scala.collection.GenTraversableOnce[Double]</td><td></td><td></td></tr>
<tr><td>collections</td><td>median</td><td>core.Solving.Statistics.median(i: scala.collection.GenTraversableOnce[Double]): Double</td><td>Double</td><td>i:scala.collection.GenTraversableOnce[Double]</td><td></td><td></td></tr>
<tr><td>collections</td><td>modeDouble</td><td>core.Solving.Statistics.modeDouble(i: scala.collection.GenTraversableOnce[Double]): Double</td><td>Double</td><td>i:scala.collection.GenTraversableOnce[Double]</td><td></td><td></td></tr>
<tr><td>collections</td><td>mode</td><td>core.Solving.Statistics.mode[T](i: scala.collection.GenTraversableOnce[T]): Option[T]</td><td>Option[T]</td><td>i:scala.collection.GenTraversableOnce[T]</td><td></td><td></td></tr>
<tr><td>collections</td><td>stddev</td><td>core.Solving.Statistics.stddev(xs: scala.collection.GenTraversableOnce[Double]): Double</td><td>Double</td><td>xs:scala.collection.GenTraversableOnce[Double]</td><td></td><td></td></tr>
<tr><td>collections</td><td>fftHist</td><td>core.common.datastructures.NumericTimeSeries.fftHist(ts: core.common.datastructures.TimeSeries[Double]): scala.collection.immutable.Vector[(Double,Double)]</td><td>scala.collection.immutable.Vector[(Double, Double)]</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>collections</td><td>simplePolynomialNextSeries</td><td>core.common.datastructures.NumericTimeSeries.simplePolynomialNextSeries(ts: core.common.datastructures.TimeSeries[Double]): scala.collection.immutable.Seq[Double]</td><td>scala.collection.immutable.Seq[Double]</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>collections</td><td>new Histogram</td><td>new core.datastructures.Histogram(it: scala.collection.GenTraversableOnce[A])core.datastructures.Histogram[A]</td><td>core.datastructures.Histogram[A]</td><td>it:scala.collection.GenTraversableOnce[A]</td><td></td><td></td></tr>
<tr><td>collections</td><td>new Range</td><td>new scala.collection.immutable.Range(start: Int, end: Int, step: Int)scala.collection.immutable.Range</td><td>scala.collection.immutable.Range</td><td>start:Int</td><td>end:Int</td><td>step:Int</td></tr>
<tr><td>collections</td><td>new Inclusive</td><td>new scala.collection.immutable.Range.Inclusive(start: Int, end: Int, step: Int)scala.collection.immutable.Range.Inclusive</td><td>scala.collection.immutable.Range.Inclusive</td><td>start:Int</td><td>end:Int</td><td>step:Int</td></tr>
<tr><td>collections</td><td>sameElements</td><td>scala.collection.GenIterableLike.sameElements[A1&gt;:A](that: scala.collection.GenIterable[A1]): Boolean</td><td>Boolean</td><td>GenIterableLike:scala.collection.GenIterableLike[A,Repr]</td><td>that:scala.collection.GenIterable[A1]</td><td></td></tr>
<tr><td>collections</td><td>$minus</td><td>scala.collection.GenMapLike.$minus(key: A): Repr</td><td>Repr</td><td>GenMapLike:scala.collection.GenMapLike[A,B,Repr]</td><td>key:A</td><td></td></tr>
<tr><td>collections</td><td>apply</td><td>scala.collection.GenMapLike.apply(key: A): B</td><td>B</td><td>GenMapLike:scala.collection.GenMapLike[A,B,Repr]</td><td>key:A</td><td></td></tr>
<tr><td>collections</td><td>contains</td><td>scala.collection.GenMapLike.contains(key: A): Boolean</td><td>Boolean</td><td>GenMapLike:scala.collection.GenMapLike[A,B,Repr]</td><td>key:A</td><td></td></tr>
<tr><td>collections</td><td>get</td><td>scala.collection.GenMapLike.get(key: A): Option[B]</td><td>Option[B]</td><td>GenMapLike:scala.collection.GenMapLike[A,B,Repr]</td><td>key:A</td><td></td></tr>
<tr><td>collections</td><td>getOrElse</td><td>scala.collection.GenMapLike.getOrElse[B1&gt;:B](key: A,default: =&gt; B1): B1</td><td>B1</td><td>GenMapLike:scala.collection.GenMapLike[A,B,Repr]</td><td>key:A</td><td>default:=&gt; B1</td></tr>
<tr><td>collections</td><td>isDefinedAt</td><td>scala.collection.GenMapLike.isDefinedAt(key: A): Boolean</td><td>Boolean</td><td>GenMapLike:scala.collection.GenMapLike[A,B,Repr]</td><td>key:A</td><td></td></tr>
<tr><td>collections</td><td>keysIterator</td><td>scala.collection.GenMapLike.keysIterator: Iterator[A]</td><td>Iterator[A]</td><td>GenMapLike:scala.collection.GenMapLike[A,B,Repr]</td><td></td><td></td></tr>
<tr><td>collections</td><td>apply</td><td>scala.collection.GenSeqLike.apply(idx: Int): A</td><td>A</td><td>GenSeqLike:scala.collection.GenSeqLike[A,Repr]</td><td>idx:Int</td><td></td></tr>
<tr><td>collections</td><td>diff</td><td>scala.collection.GenSeqLike.diff[B&gt;:A](that: scala.collection.GenSeq[B]): Repr</td><td>Repr</td><td>GenSeqLike:scala.collection.GenSeqLike[A,Repr]</td><td>that:scala.collection.GenSeq[B]</td><td></td></tr>
<tr><td>collections</td><td>distinct</td><td>scala.collection.GenSeqLike.distinct: Repr</td><td>Repr</td><td>GenSeqLike:scala.collection.GenSeqLike[A,Repr]</td><td></td><td></td></tr>
<tr><td>collections</td><td>endsWith</td><td>scala.collection.GenSeqLike.endsWith[B](that: scala.collection.GenSeq[B]): Boolean</td><td>Boolean</td><td>GenSeqLike:scala.collection.GenSeqLike[A,Repr]</td><td>that:scala.collection.GenSeq[B]</td><td></td></tr>
<tr><td>collections</td><td>indexOf</td><td>scala.collection.GenSeqLike.indexOf[B&gt;:A](elem: B): Int</td><td>Int</td><td>GenSeqLike:scala.collection.GenSeqLike[A,Repr]</td><td>elem:B</td><td></td></tr>
<tr><td>collections</td><td>indexOf</td><td>scala.collection.GenSeqLike.indexOf[B&gt;:A](elem: B,from: Int): Int</td><td>Int</td><td>GenSeqLike:scala.collection.GenSeqLike[A,Repr]</td><td>elem:B</td><td>from:Int</td></tr>
<tr><td>collections</td><td>intersect</td><td>scala.collection.GenSeqLike.intersect[B&gt;:A](that: scala.collection.GenSeq[B]): Repr</td><td>Repr</td><td>GenSeqLike:scala.collection.GenSeqLike[A,Repr]</td><td>that:scala.collection.GenSeq[B]</td><td></td></tr>
<tr><td>collections</td><td>isDefinedAt</td><td>scala.collection.GenSeqLike.isDefinedAt(idx: Int): Boolean</td><td>Boolean</td><td>GenSeqLike:scala.collection.GenSeqLike[A,Repr]</td><td>idx:Int</td><td></td></tr>
<tr><td>collections</td><td>reverse</td><td>scala.collection.GenSeqLike.reverse: Repr</td><td>Repr</td><td>GenSeqLike:scala.collection.GenSeqLike[A,Repr]</td><td></td><td></td></tr>
<tr><td>collections</td><td>startsWith</td><td>scala.collection.GenSeqLike.startsWith[B](that: scala.collection.GenSeq[B]): Boolean</td><td>Boolean</td><td>GenSeqLike:scala.collection.GenSeqLike[A,Repr]</td><td>that:scala.collection.GenSeq[B]</td><td></td></tr>
<tr><td>collections</td><td>startsWith</td><td>scala.collection.GenSeqLike.startsWith[B](that: scala.collection.GenSeq[B],offset: Int): Boolean</td><td>Boolean</td><td>GenSeqLike:scala.collection.GenSeqLike[A,Repr]</td><td>that:scala.collection.GenSeq[B]</td><td>offset:Int</td></tr>
<tr><td>collections</td><td>$minus</td><td>scala.collection.GenSetLike.$minus(elem: A): Repr</td><td>Repr</td><td>GenSetLike:scala.collection.GenSetLike[A,Repr]</td><td>elem:A</td><td></td></tr>
<tr><td>collections</td><td>$plus</td><td>scala.collection.GenSetLike.$plus(elem: A): Repr</td><td>Repr</td><td>GenSetLike:scala.collection.GenSetLike[A,Repr]</td><td>elem:A</td><td></td></tr>
<tr><td>collections</td><td>apply</td><td>scala.collection.GenSetLike.apply(elem: A): Boolean</td><td>Boolean</td><td>GenSetLike:scala.collection.GenSetLike[A,Repr]</td><td>elem:A</td><td></td></tr>
<tr><td>collections</td><td>contains</td><td>scala.collection.GenSetLike.contains(elem: A): Boolean</td><td>Boolean</td><td>GenSetLike:scala.collection.GenSetLike[A,Repr]</td><td>elem:A</td><td></td></tr>
<tr><td>collections</td><td>diff</td><td>scala.collection.GenSetLike.diff(that: scala.collection.GenSet[A]): Repr</td><td>Repr</td><td>GenSetLike:scala.collection.GenSetLike[A,Repr]</td><td>that:scala.collection.GenSet[A]</td><td></td></tr>
<tr><td>collections</td><td>intersect</td><td>scala.collection.GenSetLike.intersect(that: scala.collection.GenSet[A]): Repr</td><td>Repr</td><td>GenSetLike:scala.collection.GenSetLike[A,Repr]</td><td>that:scala.collection.GenSet[A]</td><td></td></tr>
<tr><td>collections</td><td>subsetOf</td><td>scala.collection.GenSetLike.subsetOf(that: scala.collection.GenSet[A]): Boolean</td><td>Boolean</td><td>GenSetLike:scala.collection.GenSetLike[A,Repr]</td><td>that:scala.collection.GenSet[A]</td><td></td></tr>
<tr><td>collections</td><td>union</td><td>scala.collection.GenSetLike.union(that: scala.collection.GenSet[A]): Repr</td><td>Repr</td><td>GenSetLike:scala.collection.GenSetLike[A,Repr]</td><td>that:scala.collection.GenSet[A]</td><td></td></tr>
<tr><td>collections</td><td>drop</td><td>scala.collection.GenTraversableLike.drop(n: Int): Repr</td><td>Repr</td><td>GenTraversableLike:scala.collection.GenTraversableLike[A,Repr]</td><td>n:Int</td><td></td></tr>
<tr><td>collections</td><td>head</td><td>scala.collection.GenTraversableLike.head: A</td><td>A</td><td>GenTraversableLike:scala.collection.GenTraversableLike[A,Repr]</td><td></td><td></td></tr>
<tr><td>collections</td><td>headOption</td><td>scala.collection.GenTraversableLike.headOption: Option[A]</td><td>Option[A]</td><td>GenTraversableLike:scala.collection.GenTraversableLike[A,Repr]</td><td></td><td></td></tr>
<tr><td>collections</td><td>last</td><td>scala.collection.GenTraversableLike.last: A</td><td>A</td><td>GenTraversableLike:scala.collection.GenTraversableLike[A,Repr]</td><td></td><td></td></tr>
<tr><td>collections</td><td>lastOption</td><td>scala.collection.GenTraversableLike.lastOption: Option[A]</td><td>Option[A]</td><td>GenTraversableLike:scala.collection.GenTraversableLike[A,Repr]</td><td></td><td></td></tr>
<tr><td>collections</td><td>slice</td><td>scala.collection.GenTraversableLike.slice(unc_from: Int,unc_until: Int): Repr</td><td>Repr</td><td>GenTraversableLike:scala.collection.GenTraversableLike[A,Repr]</td><td>unc_from:Int</td><td>unc_until:Int</td></tr>
<tr><td>collections</td><td>tail</td><td>scala.collection.GenTraversableLike.tail: Repr</td><td>Repr</td><td>GenTraversableLike:scala.collection.GenTraversableLike[A,Repr]</td><td></td><td></td></tr>
<tr><td>collections</td><td>take</td><td>scala.collection.GenTraversableLike.take(n: Int): Repr</td><td>Repr</td><td>GenTraversableLike:scala.collection.GenTraversableLike[A,Repr]</td><td>n:Int</td><td></td></tr>
<tr><td>collections</td><td>isEmpty</td><td>scala.collection.GenTraversableOnce.isEmpty: Boolean</td><td>Boolean</td><td>GenTraversableOnce:scala.collection.GenTraversableOnce[A]</td><td></td><td></td></tr>
<tr><td>collections</td><td>mkString</td><td>scala.collection.GenTraversableOnce.mkString(sep: String): String</td><td>String</td><td>GenTraversableOnce:scala.collection.GenTraversableOnce[A]</td><td>sep:String</td><td></td></tr>
<tr><td>collections</td><td>mkString</td><td>scala.collection.GenTraversableOnce.mkString(start: String,sep: String,end: String): String</td><td>String</td><td>GenTraversableOnce:scala.collection.GenTraversableOnce[A]</td><td>start:String</td><td>sep:String</td></tr>
<tr><td>collections</td><td>mkString</td><td>scala.collection.GenTraversableOnce.mkString: String</td><td>String</td><td>GenTraversableOnce:scala.collection.GenTraversableOnce[A]</td><td></td><td></td></tr>
<tr><td>collections</td><td>nonEmpty</td><td>scala.collection.GenTraversableOnce.nonEmpty: Boolean</td><td>Boolean</td><td>GenTraversableOnce:scala.collection.GenTraversableOnce[A]</td><td></td><td></td></tr>
<tr><td>collections</td><td>size</td><td>scala.collection.GenTraversableOnce.size: Int</td><td>Int</td><td>GenTraversableOnce:scala.collection.GenTraversableOnce[A]</td><td></td><td></td></tr>
<tr><td>collections</td><td>dropRight</td><td>scala.collection.IterableLike.dropRight(n: Int): Repr</td><td>Repr</td><td>IterableLike:scala.collection.IterableLike[A,Repr]</td><td>n:Int</td><td></td></tr>
<tr><td>collections</td><td>grouped</td><td>scala.collection.IterableLike.grouped(size: Int): Iterator[Repr]</td><td>Iterator[Repr]</td><td>IterableLike:scala.collection.IterableLike[A,Repr]</td><td>size:Int</td><td></td></tr>
<tr><td>collections</td><td>sliding</td><td>scala.collection.IterableLike.sliding(size: Int): Iterator[Repr]</td><td>Iterator[Repr]</td><td>IterableLike:scala.collection.IterableLike[A,Repr]</td><td>size:Int</td><td></td></tr>
<tr><td>collections</td><td>sliding</td><td>scala.collection.IterableLike.sliding(size: Int,step: Int): Iterator[Repr]</td><td>Iterator[Repr]</td><td>IterableLike:scala.collection.IterableLike[A,Repr]</td><td>size:Int</td><td>step:Int</td></tr>
<tr><td>collections</td><td>takeRight</td><td>scala.collection.IterableLike.takeRight(n: Int): Repr</td><td>Repr</td><td>IterableLike:scala.collection.IterableLike[A,Repr]</td><td>n:Int</td><td></td></tr>
<tr><td>collections</td><td>empty</td><td>scala.collection.Map.empty: scala.collection.Map[A,B]</td><td>scala.collection.Map[A,B]</td><td>Map:scala.collection.Map[A,B]</td><td></td><td></td></tr>
<tr><td>collections</td><td>$minus</td><td>scala.collection.MapLike.$minus(key: A): This</td><td>This</td><td>MapLike:scala.collection.MapLike[A,B,This]</td><td>key:A</td><td></td></tr>
<tr><td>collections</td><td>empty</td><td>scala.collection.MapLike.empty: This</td><td>This</td><td>MapLike:scala.collection.MapLike[A,B,This]</td><td></td><td></td></tr>
<tr><td>collections</td><td>iterator</td><td>scala.collection.MapLike.iterator=&gt;Iterator[: Iterator[(A,B)]</td><td>Iterator[(A, B)]</td><td>MapLike:scala.collection.MapLike[A,B,This]</td><td></td><td></td></tr>
<tr><td>collections</td><td>keySet</td><td>scala.collection.MapLike.keySet: scala.collection.Set[A]</td><td>scala.collection.Set[A]</td><td>MapLike:scala.collection.MapLike[A,B,This]</td><td></td><td></td></tr>
<tr><td>collections</td><td>keys</td><td>scala.collection.MapLike.keys: Iterable[A]</td><td>Iterable[A]</td><td>MapLike:scala.collection.MapLike[A,B,This]</td><td></td><td></td></tr>
<tr><td>collections</td><td>toSeq</td><td>scala.collection.MapLike.toSeq=&gt;Seq[: Seq[(A,B)]</td><td>Seq[(A, B)]</td><td>MapLike:scala.collection.MapLike[A,B,This]</td><td></td><td></td></tr>
<tr><td>collections</td><td>updated</td><td>scala.collection.MapLike.updated[B1&gt;:B](key: A,value: B1): scala.collection.Map[A,B1]</td><td>scala.collection.Map[A,B1]</td><td>MapLike:scala.collection.MapLike[A,B,This]</td><td>key:A</td><td>value:B1</td></tr>
<tr><td>collections</td><td>values</td><td>scala.collection.MapLike.values: Iterable[B]</td><td>Iterable[B]</td><td>MapLike:scala.collection.MapLike[A,B,This]</td><td></td><td></td></tr>
<tr><td>collections</td><td>containsSlice</td><td>scala.collection.SeqLike.containsSlice[B](that: scala.collection.GenSeq[B]): Boolean</td><td>Boolean</td><td>SeqLike:scala.collection.SeqLike[A,Repr]</td><td>that:scala.collection.GenSeq[B]</td><td></td></tr>
<tr><td>collections</td><td>contains</td><td>scala.collection.SeqLike.contains[A1&gt;:A](elem: A1): Boolean</td><td>Boolean</td><td>SeqLike:scala.collection.SeqLike[A,Repr]</td><td>elem:A1</td><td></td></tr>
<tr><td>collections</td><td>indexOfSlice</td><td>scala.collection.SeqLike.indexOfSlice[B&gt;:A](that: scala.collection.GenSeq[B]): Int</td><td>Int</td><td>SeqLike:scala.collection.SeqLike[A,Repr]</td><td>that:scala.collection.GenSeq[B]</td><td></td></tr>
<tr><td>collections</td><td>indexOfSlice</td><td>scala.collection.SeqLike.indexOfSlice[B&gt;:A](that: scala.collection.GenSeq[B],from: Int): Int</td><td>Int</td><td>SeqLike:scala.collection.SeqLike[A,Repr]</td><td>that:scala.collection.GenSeq[B]</td><td>from:Int</td></tr>
<tr><td>collections</td><td>indices</td><td>scala.collection.SeqLike.indices: scala.collection.immutable.Range</td><td>scala.collection.immutable.Range</td><td>SeqLike:scala.collection.SeqLike[A,Repr]</td><td></td><td></td></tr>
<tr><td>collections</td><td>$minus</td><td>scala.collection.SetLike.$minus(elem: A): This</td><td>This</td><td>SetLike:scala.collection.SetLike[A,This]</td><td>elem:A</td><td></td></tr>
<tr><td>collections</td><td>$plus$plus</td><td>scala.collection.SetLike.$plus$plus(elems: scala.collection.GenTraversableOnce[A]): This</td><td>This</td><td>SetLike:scala.collection.SetLike[A,This]</td><td>elems:scala.collection.GenTraversableOnce[A]</td><td></td></tr>
<tr><td>collections</td><td>$plus</td><td>scala.collection.SetLike.$plus(elem: A): This</td><td>This</td><td>SetLike:scala.collection.SetLike[A,This]</td><td>elem:A</td><td></td></tr>
<tr><td>collections</td><td>diff</td><td>scala.collection.SetLike.diff(that: scala.collection.GenSet[A]): This</td><td>This</td><td>SetLike:scala.collection.SetLike[A,This]</td><td>that:scala.collection.GenSet[A]</td><td></td></tr>
<tr><td>collections</td><td>union</td><td>scala.collection.SetLike.union(that: scala.collection.GenSet[A]): This</td><td>This</td><td>SetLike:scala.collection.SetLike[A,This]</td><td>that:scala.collection.GenSet[A]</td><td></td></tr>
<tr><td>collections</td><td>toSeq</td><td>scala.collection.TraversableOnce.toSeq: Seq[A]</td><td>Seq[A]</td><td>TraversableOnce:scala.collection.TraversableOnce[A]</td><td></td><td></td></tr>
<tr><td>collections</td><td>$plus$eq</td><td>scala.collection.generic.Growable.$plus$eq(elem: A): Growable.this.type</td><td>scala.collection.generic.Growable[A]</td><td>Growable:scala.collection.generic.Growable[A]</td><td>elem:A</td><td></td></tr>
<tr><td>collections</td><td>$plus$plus$eq</td><td>scala.collection.generic.Growable.$plus$plus$eq(xs: scala.collection.TraversableOnce[A]): Growable.this.type</td><td>scala.collection.generic.Growable[A]</td><td>Growable:scala.collection.generic.Growable[A]</td><td>xs:scala.collection.TraversableOnce[A]</td><td></td></tr>
<tr><td>collections</td><td>$minus$eq</td><td>scala.collection.generic.Shrinkable.$minus$eq(elem: A): Shrinkable.this.type</td><td>scala.collection.generic.Shrinkable[A]</td><td>Shrinkable:scala.collection.generic.Shrinkable[A]</td><td>elem:A</td><td></td></tr>
<tr><td>collections</td><td>$minus</td><td>scala.collection.generic.Subtractable.$minus(elem: A): Repr</td><td>Repr</td><td>Subtractable:scala.collection.generic.Subtractable[A,Repr]</td><td>elem:A</td><td></td></tr>
<tr><td>collections</td><td>apply</td><td>scala.collection.immutable.$colon$colon.apply[B](head: B,tl: List[B]): scala.collection.immutable.::[B]</td><td>List[B]</td><td>head:B</td><td>tl:List[B]</td><td></td></tr>
<tr><td>collections</td><td>head</td><td>scala.collection.immutable.$colon$colon.head: B</td><td>B</td><td>$colon$colon:scala.collection.immutable.::[B]</td><td></td><td></td></tr>
<tr><td>collections</td><td>tail</td><td>scala.collection.immutable.$colon$colon.tail: List[B]</td><td>List[B]</td><td>$colon$colon:scala.collection.immutable.::[B]</td><td></td><td></td></tr>
<tr><td>collections</td><td>$colon$colon$colon</td><td>scala.collection.immutable.List.$colon$colon$colon[B&gt;:A](prefix: List[B]): List[B]</td><td>List[B]</td><td>List:List[A]</td><td>prefix:List[B]</td><td></td></tr>
<tr><td>collections</td><td>$colon$colon</td><td>scala.collection.immutable.List.$colon$colon[B&gt;:A](x: B): List[B]</td><td>List[B]</td><td>List:List[A]</td><td>x:B</td><td></td></tr>
<tr><td>collections</td><td>drop</td><td>scala.collection.immutable.List.drop(n: Int): List[A]</td><td>List[A]</td><td>List:List[A]</td><td>n:Int</td><td></td></tr>
<tr><td>collections</td><td>reverse</td><td>scala.collection.immutable.List.reverse: List[A]</td><td>List[A]</td><td>List:List[A]</td><td></td><td></td></tr>
<tr><td>collections</td><td>slice</td><td>scala.collection.immutable.List.slice(from: Int,until: Int): List[A]</td><td>List[A]</td><td>List:List[A]</td><td>from:Int</td><td>until:Int</td></tr>
<tr><td>collections</td><td>tail</td><td>scala.collection.immutable.List.tail: List[A]</td><td>List[A]</td><td>List:List[A]</td><td></td><td></td></tr>
<tr><td>collections</td><td>take</td><td>scala.collection.immutable.List.take(n: Int): List[A]</td><td>List[A]</td><td>List:List[A]</td><td>n:Int</td><td></td></tr>
<tr><td>collections</td><td>takeRight</td><td>scala.collection.immutable.List.takeRight(n: Int): List[A]</td><td>List[A]</td><td>List:List[A]</td><td>n:Int</td><td></td></tr>
<tr><td>collections</td><td>empty</td><td>scala.collection.immutable.Map.empty: scala.collection.immutable.Map[A,B]</td><td>scala.collection.immutable.Map[A,B]</td><td>Map:scala.collection.immutable.Map[A,B]</td><td></td><td></td></tr>
<tr><td>collections</td><td>updated</td><td>scala.collection.immutable.Map.updated[B1&gt;:B](key: A,value: B1): scala.collection.immutable.Map[A,B1]</td><td>scala.collection.immutable.Map[A,B1]</td><td>Map:scala.collection.immutable.Map[A,B]</td><td>key:A</td><td>value:B1</td></tr>
<tr><td>collections</td><td>keySet</td><td>scala.collection.immutable.MapLike.keySet: scala.collection.immutable.Set[A]</td><td>scala.collection.immutable.Set[A]</td><td>MapLike:scala.collection.immutable.MapLike[A,B,This]</td><td></td><td></td></tr>
<tr><td>collections</td><td>updated</td><td>scala.collection.immutable.MapLike.updated[B1&gt;:B](key: A,value: B1): scala.collection.immutable.Map[A,B1]</td><td>scala.collection.immutable.Map[A,B1]</td><td>MapLike:scala.collection.immutable.MapLike[A,B,This]</td><td>key:A</td><td>value:B1</td></tr>
<tr><td>collections</td><td>apply</td><td>scala.collection.immutable.Range.apply(idx: Int): Int</td><td>Int</td><td>Range:scala.collection.immutable.Range</td><td>idx:Int</td><td></td></tr>
<tr><td>collections</td><td>apply</td><td>scala.collection.immutable.Range.apply(start: Int,end: Int): scala.collection.immutable.Range</td><td>scala.collection.immutable.Range</td><td>start:Int</td><td>end:Int</td><td></td></tr>
<tr><td>collections</td><td>apply</td><td>scala.collection.immutable.Range.apply(start: Int,end: Int,step: Int): scala.collection.immutable.Range</td><td>scala.collection.immutable.Range</td><td>start:Int</td><td>end:Int</td><td>step:Int</td></tr>
<tr><td>collections</td><td>by</td><td>scala.collection.immutable.Range.by(step: Int): scala.collection.immutable.Range</td><td>scala.collection.immutable.Range</td><td>Range:scala.collection.immutable.Range</td><td>step:Int</td><td></td></tr>
<tr><td>collections</td><td>contains</td><td>scala.collection.immutable.Range.contains(x: Int): Boolean</td><td>Boolean</td><td>Range:scala.collection.immutable.Range</td><td>x:Int</td><td></td></tr>
<tr><td>collections</td><td>drop</td><td>scala.collection.immutable.Range.drop(n: Int): scala.collection.immutable.Range</td><td>scala.collection.immutable.Range</td><td>Range:scala.collection.immutable.Range</td><td>n:Int</td><td></td></tr>
<tr><td>collections</td><td>dropRight</td><td>scala.collection.immutable.Range.dropRight(n: Int): scala.collection.immutable.Range</td><td>scala.collection.immutable.Range</td><td>Range:scala.collection.immutable.Range</td><td>n:Int</td><td></td></tr>
<tr><td>collections</td><td>end</td><td>scala.collection.immutable.Range.end: Int</td><td>Int</td><td>Range:scala.collection.immutable.Range</td><td></td><td></td></tr>
<tr><td>collections</td><td>head</td><td>scala.collection.immutable.Range.head: Int</td><td>Int</td><td>Range:scala.collection.immutable.Range</td><td></td><td></td></tr>
<tr><td>collections</td><td>inclusive</td><td>scala.collection.immutable.Range.inclusive: scala.collection.immutable.Range</td><td>scala.collection.immutable.Range</td><td>Range:scala.collection.immutable.Range</td><td></td><td></td></tr>
<tr><td>collections</td><td>init</td><td>scala.collection.immutable.Range.init: scala.collection.immutable.Range</td><td>scala.collection.immutable.Range</td><td>Range:scala.collection.immutable.Range</td><td></td><td></td></tr>
<tr><td>collections</td><td>isInclusive</td><td>scala.collection.immutable.Range.isInclusive: Boolean</td><td>Boolean</td><td>Range:scala.collection.immutable.Range</td><td></td><td></td></tr>
<tr><td>collections</td><td>last</td><td>scala.collection.immutable.Range.last: Int</td><td>Int</td><td>Range:scala.collection.immutable.Range</td><td></td><td></td></tr>
<tr><td>collections</td><td>lastElement</td><td>scala.collection.immutable.Range.lastElement: Int</td><td>Int</td><td>Range:scala.collection.immutable.Range</td><td></td><td></td></tr>
<tr><td>collections</td><td>numRangeElements</td><td>scala.collection.immutable.Range.numRangeElements: Int</td><td>Int</td><td>Range:scala.collection.immutable.Range</td><td></td><td></td></tr>
<tr><td>collections</td><td>reverse</td><td>scala.collection.immutable.Range.reverse: scala.collection.immutable.Range</td><td>scala.collection.immutable.Range</td><td>Range:scala.collection.immutable.Range</td><td></td><td></td></tr>
<tr><td>collections</td><td>start</td><td>scala.collection.immutable.Range.start: Int</td><td>Int</td><td>Range:scala.collection.immutable.Range</td><td></td><td></td></tr>
<tr><td>collections</td><td>step</td><td>scala.collection.immutable.Range.step: Int</td><td>Int</td><td>Range:scala.collection.immutable.Range</td><td></td><td></td></tr>
<tr><td>collections</td><td>tail</td><td>scala.collection.immutable.Range.tail: scala.collection.immutable.Range</td><td>scala.collection.immutable.Range</td><td>Range:scala.collection.immutable.Range</td><td></td><td></td></tr>
<tr><td>collections</td><td>take</td><td>scala.collection.immutable.Range.take(n: Int): scala.collection.immutable.Range</td><td>scala.collection.immutable.Range</td><td>Range:scala.collection.immutable.Range</td><td>n:Int</td><td></td></tr>
<tr><td>collections</td><td>takeRight</td><td>scala.collection.immutable.Range.takeRight(n: Int): scala.collection.immutable.Range</td><td>scala.collection.immutable.Range</td><td>Range:scala.collection.immutable.Range</td><td>n:Int</td><td></td></tr>
<tr><td>collections</td><td>terminalElement</td><td>scala.collection.immutable.Range.terminalElement: Int</td><td>Int</td><td>Range:scala.collection.immutable.Range</td><td></td><td></td></tr>
<tr><td>collections</td><td>toSeq</td><td>scala.collection.immutable.Range.toSeq: scala.collection.immutable.Range</td><td>scala.collection.immutable.Range</td><td>Range:scala.collection.immutable.Range</td><td></td><td></td></tr>
<tr><td>collections</td><td>$times</td><td>scala.collection.immutable.StringLike.$times(n: Int): String</td><td>String</td><td>StringLike:scala.collection.immutable.StringLike[Repr]</td><td>n:Int</td><td></td></tr>
<tr><td>collections</td><td>apply</td><td>scala.collection.immutable.StringLike.apply(n: Int): Char</td><td>Char</td><td>StringLike:scala.collection.immutable.StringLike[Repr]</td><td>n:Int</td><td></td></tr>
<tr><td>collections</td><td>capitalize</td><td>scala.collection.immutable.StringLike.capitalize: String</td><td>String</td><td>StringLike:scala.collection.immutable.StringLike[Repr]</td><td></td><td></td></tr>
<tr><td>collections</td><td>lines</td><td>scala.collection.immutable.StringLike.lines: Iterator[String]</td><td>Iterator[String]</td><td>StringLike:scala.collection.immutable.StringLike[Repr]</td><td></td><td></td></tr>
<tr><td>collections</td><td>linesIterator</td><td>scala.collection.immutable.StringLike.linesIterator: Iterator[String]</td><td>Iterator[String]</td><td>StringLike:scala.collection.immutable.StringLike[Repr]</td><td></td><td></td></tr>
<tr><td>collections</td><td>linesWithSeparators</td><td>scala.collection.immutable.StringLike.linesWithSeparators: Iterator[String]</td><td>Iterator[String]</td><td>StringLike:scala.collection.immutable.StringLike[Repr]</td><td></td><td></td></tr>
<tr><td>collections</td><td>replaceAllLiterally</td><td>scala.collection.immutable.StringLike.replaceAllLiterally(literal: String,replacement: String): String</td><td>String</td><td>StringLike:scala.collection.immutable.StringLike[Repr]</td><td>literal:String</td><td>replacement:String</td></tr>
<tr><td>collections</td><td>split</td><td>scala.collection.immutable.StringLike.split(separator: Char): Array[String]</td><td>Array[String]</td><td>StringLike:scala.collection.immutable.StringLike[Repr]</td><td>separator:Char</td><td></td></tr>
<tr><td>collections</td><td>split</td><td>scala.collection.immutable.StringLike.split(separators: Array[Char]): Array[String]</td><td>Array[String]</td><td>StringLike:scala.collection.immutable.StringLike[Repr]</td><td>separators:Array[Char]</td><td></td></tr>
<tr><td>collections</td><td>stripLineEnd</td><td>scala.collection.immutable.StringLike.stripLineEnd: String</td><td>String</td><td>StringLike:scala.collection.immutable.StringLike[Repr]</td><td></td><td></td></tr>
<tr><td>collections</td><td>stripMargin</td><td>scala.collection.immutable.StringLike.stripMargin(marginChar: Char): String</td><td>String</td><td>StringLike:scala.collection.immutable.StringLike[Repr]</td><td>marginChar:Char</td><td></td></tr>
<tr><td>collections</td><td>stripMargin</td><td>scala.collection.immutable.StringLike.stripMargin: String</td><td>String</td><td>StringLike:scala.collection.immutable.StringLike[Repr]</td><td></td><td></td></tr>
<tr><td>collections</td><td>stripPrefix</td><td>scala.collection.immutable.StringLike.stripPrefix(prefix: String): String</td><td>String</td><td>StringLike:scala.collection.immutable.StringLike[Repr]</td><td>prefix:String</td><td></td></tr>
<tr><td>collections</td><td>stripSuffix</td><td>scala.collection.immutable.StringLike.stripSuffix(suffix: String): String</td><td>String</td><td>StringLike:scala.collection.immutable.StringLike[Repr]</td><td>suffix:String</td><td></td></tr>
<tr><td>collections</td><td>toBoolean</td><td>scala.collection.immutable.StringLike.toBoolean: Boolean</td><td>Boolean</td><td>StringLike:scala.collection.immutable.StringLike[Repr]</td><td></td><td></td></tr>
<tr><td>collections</td><td>toDouble</td><td>scala.collection.immutable.StringLike.toDouble: Double</td><td>Double</td><td>StringLike:scala.collection.immutable.StringLike[Repr]</td><td></td><td></td></tr>
<tr><td>collections</td><td>toInt</td><td>scala.collection.immutable.StringLike.toInt: Int</td><td>Int</td><td>StringLike:scala.collection.immutable.StringLike[Repr]</td><td></td><td></td></tr>
<tr><td>collections</td><td>toLong</td><td>scala.collection.immutable.StringLike.toLong: Long</td><td>Long</td><td>StringLike:scala.collection.immutable.StringLike[Repr]</td><td></td><td></td></tr>
<tr><td>collections</td><td>slice</td><td>scala.collection.immutable.WrappedString.slice(from: Int,until: Int): scala.collection.immutable.WrappedString</td><td>scala.collection.immutable.WrappedString</td><td>WrappedString:scala.collection.immutable.WrappedString</td><td>from:Int</td><td>until:Int</td></tr>
<tr><td>collections, math</td><td>abstractionsNormalized</td><td>core.Solving.provider.CustomGraphFuzzy.abstractionsNormalized(text: core.nlp.SemanticWrapper): scala.collection.mutable.HashMap[core.Solving.provider.CustomGraphFuzzy.CustomGraphValue,Double]</td><td>scala.collection.mutable.HashMap[core.Solving.provider.CustomGraphFuzzy.CustomGraphValue,Double]</td><td>text:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>collections, math</td><td>abstractionsWeighted</td><td>core.Solving.provider.CustomGraphFuzzy.abstractionsWeighted(text: core.nlp.SemanticWrapper): scala.collection.mutable.HashMap[(String,String),Double]</td><td>scala.collection.mutable.HashMap[(String, String),Double]</td><td>text:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>core.Solving.GraphFunctions</td><td>domainSubject</td><td>core.Solving.GraphFunctions.domainSubject(u: core.datastructures.URLTrait): core.datastructures.graph.traversal.NodeList</td><td>core.datastructures.graph.traversal.NodeList</td><td>u:core.datastructures.URLTrait</td><td></td><td></td></tr>
<tr><td>core.Solving.GraphFunctions</td><td>extractEntities</td><td>core.Solving.GraphFunctions.extractEntities(text: core.nlp.SemanticWrapper,additionalLexicon: Set[String]): List[String]</td><td>List[String]</td><td>text:core.nlp.SemanticWrapper</td><td>additionalLexicon:Set[String]</td><td></td></tr>
<tr><td>core.Solving.GraphFunctions</td><td>urlTokenCategories</td><td>core.Solving.GraphFunctions.urlTokenCategories(u: core.datastructures.URLTrait): core.datastructures.graph.traversal.NodeList</td><td>core.datastructures.graph.traversal.NodeList</td><td>u:core.datastructures.URLTrait</td><td></td><td></td></tr>
<tr><td>core.Solving.NumericSeqPairs</td><td>correlationInt</td><td>core.Solving.NumericSeqPairs.correlationInt(a: Seq[Int],b: Seq[Int]): Double</td><td>Double</td><td>a:Seq[Int]</td><td>b:Seq[Int]</td><td></td></tr>
<tr><td>core.Solving.NumericSeqPairs</td><td>pearsonCorrelation</td><td>core.Solving.NumericSeqPairs.pearsonCorrelation(a: Seq[Double],b: Seq[Double]): Double</td><td>Double</td><td>a:Seq[Double]</td><td>b:Seq[Double]</td><td></td></tr>
<tr><td>core.Solving.NumericSeqPairs</td><td>rankCorrelation</td><td>core.Solving.NumericSeqPairs.rankCorrelation(a: Seq[Double],b: Seq[Double]): Double</td><td>Double</td><td>a:Seq[Double]</td><td>b:Seq[Double]</td><td></td></tr>
<tr><td>core.Solving.NumericSeqPairs</td><td>tauCorrelation</td><td>core.Solving.NumericSeqPairs.tauCorrelation(a: Seq[Double],b: Seq[Double]): Double</td><td>Double</td><td>a:Seq[Double]</td><td>b:Seq[Double]</td><td></td></tr>
<tr><td>core.Solving.NumericSeqPairs</td><td>tauDistance</td><td>core.Solving.NumericSeqPairs.tauDistance[A](a: Seq[A],b: Seq[A]): Int</td><td>Int</td><td>a:Seq[A]</td><td>b:Seq[A]</td><td></td></tr>
<tr><td>core.Solving.SeqPairs</td><td>sizesCompare</td><td>core.Solving.SeqPairs.sizesCompare(a: Seq[Any],b: Seq[Any]): Boolean</td><td>Boolean</td><td>a:Seq[Any]</td><td>b:Seq[Any]</td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>applyCyclic</td><td>core.Solving.SpecialFunctions.applyCyclic[A](v: List[A],n: Int): A</td><td>A</td><td>v:List[A]</td><td>n:Int</td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>applyRepeating</td><td>core.Solving.SpecialFunctions.applyRepeating[A](v: List[A],n: Int): A</td><td>A</td><td>v:List[A]</td><td>n:Int</td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>arithmeticImplication</td><td>core.Solving.SpecialFunctions.arithmeticImplication(a: Double,b: Double): Double</td><td>Double</td><td>a:Double</td><td>b:Double</td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>arithmeticNot</td><td>core.Solving.SpecialFunctions.arithmeticNot(a: Double): Double</td><td>Double</td><td>a:Double</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>avg</td><td>core.Solving.SpecialFunctions.avg(a: Double,b: Double): Double</td><td>Double</td><td>a:Double</td><td>b:Double</td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>cubed</td><td>core.Solving.SpecialFunctions.cubed(num: Double): Double</td><td>Double</td><td>num:Double</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>derivative</td><td>core.Solving.SpecialFunctions.derivative(s: Seq[(Double, Double)]): List[Double]</td><td>List[Double]</td><td>s:Seq[(Double, Double)]</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>derivativeY</td><td>core.Solving.SpecialFunctions.derivativeY(s: Seq[Double]): List[Double]</td><td>List[Double]</td><td>s:Seq[Double]</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>evenness</td><td>core.Solving.SpecialFunctions.evenness(n: Int): Int</td><td>Int</td><td>n:Int</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>firstXforYOrElse</td><td>core.Solving.SpecialFunctions.firstXforYOrElse[A,B,C&gt;:A](s: TraversableOnce[(A, B)],v: Any,default: C): C</td><td>C</td><td>s:TraversableOnce[(A, B)]</td><td>v:Any</td><td>default:C</td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>fractions</td><td>core.Solving.SpecialFunctions.fractions(s: String): Iterator[Double]</td><td>Iterator[Double]</td><td>s:String</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>getOrElseSeq</td><td>core.Solving.SpecialFunctions.getOrElseSeq[A,B,B1&gt;:B](m: TraversableOnce[(A, B)],key: A,default: B1): B1</td><td>B1</td><td>m:TraversableOnce[(A, B)]</td><td>key:A</td><td>default:B1</td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>globalDelta</td><td>core.Solving.SpecialFunctions.globalDelta(s: Seq[Double]): Double</td><td>Double</td><td>s:Seq[Double]</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>maxSlopeDouble</td><td>core.Solving.SpecialFunctions.maxSlopeDouble(s: Seq[Double]): Double</td><td>Double</td><td>s:Seq[Double]</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>maxSlopeFirstHalf</td><td>core.Solving.SpecialFunctions.maxSlopeFirstHalf(s: Seq[Double]): Double</td><td>Double</td><td>s:Seq[Double]</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>maxSlopeInt</td><td>core.Solving.SpecialFunctions.maxSlopeInt(s: Seq[Int]): Double</td><td>Double</td><td>s:Seq[Int]</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>maxSlopeSecondHalf</td><td>core.Solving.SpecialFunctions.maxSlopeSecondHalf(s: Seq[Double]): Double</td><td>Double</td><td>s:Seq[Double]</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>minSlopeDouble</td><td>core.Solving.SpecialFunctions.minSlopeDouble(s: Seq[Double]): Double</td><td>Double</td><td>s:Seq[Double]</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>minSlopeFirstHalf</td><td>core.Solving.SpecialFunctions.minSlopeFirstHalf(s: Seq[Double]): Double</td><td>Double</td><td>s:Seq[Double]</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>minSlopeInt</td><td>core.Solving.SpecialFunctions.minSlopeInt(s: Seq[Int]): Double</td><td>Double</td><td>s:Seq[Int]</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>minSlopeSecondHalf</td><td>core.Solving.SpecialFunctions.minSlopeSecondHalf(s: Seq[Double]): Double</td><td>Double</td><td>s:Seq[Double]</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>ngrams2</td><td>core.Solving.SpecialFunctions.ngrams2(s: String): List[String]</td><td>List[String]</td><td>s:String</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>ngramsForTokens</td><td>core.Solving.SpecialFunctions.ngramsForTokens(tokens: Seq[String]): List[Seq[String]]</td><td>List[Seq[String]]</td><td>tokens:Seq[String]</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>numberIn</td><td>core.Solving.SpecialFunctions.numberIn(s: String): Double</td><td>Double</td><td>s:String</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>numericPrefix</td><td>core.Solving.SpecialFunctions.numericPrefix(s: String): Double</td><td>Double</td><td>s:String</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>numericSuffix</td><td>core.Solving.SpecialFunctions.numericSuffix(s: String): Double</td><td>Double</td><td>s:String</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>ratio</td><td>core.Solving.SpecialFunctions.ratio(i1: Int,i2: Int): Double</td><td>Double</td><td>i1:Int</td><td>i2:Int</td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>relu</td><td>core.Solving.SpecialFunctions.relu(num: Double): Double</td><td>Double</td><td>num:Double</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>reluHalf</td><td>core.Solving.SpecialFunctions.reluHalf(num: Double): Double</td><td>Double</td><td>num:Double</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>reluNegative</td><td>core.Solving.SpecialFunctions.reluNegative(num: Double): Double</td><td>Double</td><td>num:Double</td><td></td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>replaceNaNsWith</td><td>core.Solving.SpecialFunctions.replaceNaNsWith(x: Double,default: Double): Double</td><td>Double</td><td>x:Double</td><td>default:Double</td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>slantedTimes1</td><td>core.Solving.SpecialFunctions.slantedTimes1(a: Double,b: Double): Double</td><td>Double</td><td>a:Double</td><td>b:Double</td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>slantedTimes2</td><td>core.Solving.SpecialFunctions.slantedTimes2(a: Double,b: Double): Double</td><td>Double</td><td>a:Double</td><td>b:Double</td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>slantedWeightedAvg1</td><td>core.Solving.SpecialFunctions.slantedWeightedAvg1(a: Double,b: Double): Double</td><td>Double</td><td>a:Double</td><td>b:Double</td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>slantedWeightedAvg2</td><td>core.Solving.SpecialFunctions.slantedWeightedAvg2(a: Double,b: Double): Double</td><td>Double</td><td>a:Double</td><td>b:Double</td><td></td></tr>
<tr><td>core.Solving.SpecialFunctions</td><td>softMax</td><td>core.Solving.SpecialFunctions.softMax(a: Double,b: Double): Double</td><td>Double</td><td>a:Double</td><td>b:Double</td><td></td></tr>
<tr><td>core.Solving.Statistics</td><td>bimodalDelta</td><td>core.Solving.Statistics.bimodalDelta(hist: core.datastructures.Histogram[Double]): Double</td><td>Double</td><td>hist:core.datastructures.Histogram[Double]</td><td></td><td></td></tr>
<tr><td>core.Solving.Statistics</td><td>maxSlope</td><td>core.Solving.Statistics.maxSlope(hist: core.datastructures.Histogram[Double]): Double</td><td>Double</td><td>hist:core.datastructures.Histogram[Double]</td><td></td><td></td></tr>
<tr><td>core.Solving.Statistics</td><td>mean</td><td>core.Solving.Statistics.mean(hist: core.datastructures.Histogram[Double]): Double</td><td>Double</td><td>hist:core.datastructures.Histogram[Double]</td><td></td><td></td></tr>
<tr><td>core.Solving.Statistics</td><td>median</td><td>core.Solving.Statistics.median(hist: core.datastructures.Histogram[Double]): Double</td><td>Double</td><td>hist:core.datastructures.Histogram[Double]</td><td></td><td></td></tr>
<tr><td>core.Solving.Statistics</td><td>minSlope</td><td>core.Solving.Statistics.minSlope(hist: core.datastructures.Histogram[Double]): Double</td><td>Double</td><td>hist:core.datastructures.Histogram[Double]</td><td></td><td></td></tr>
<tr><td>core.Solving.Statistics</td><td>stddev</td><td>core.Solving.Statistics.stddev(hist: core.datastructures.Histogram[Double]): Double</td><td>Double</td><td>hist:core.datastructures.Histogram[Double]</td><td></td><td></td></tr>
<tr><td>core.Solving.provider.CustomGraphFuzzy</td><td>load</td><td>core.Solving.provider.CustomGraphFuzzy.load(domains: Seq[String]): Unit</td><td>Unit</td><td>domains:Seq[String]</td><td></td><td></td></tr>
<tr><td>core.Solving.provider.WeatherProvider</td><td>weatherAt</td><td>core.Solving.provider.WeatherProvider.weatherAt(location: core.datastructures.LatLong,date: java.util.Date): Seq[(String,Double)]</td><td>Seq[(String, Double)]</td><td>location:core.datastructures.LatLong</td><td>date:java.util.Date</td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>$div</td><td>core.common.datastructures.NumericTimeSeries.$div(ts: core.common.datastructures.TimeSeries[Double],other: Double): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td>other:Double</td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>addReturnK</td><td>core.common.datastructures.NumericTimeSeries.addReturnK(ts: core.common.datastructures.TimeSeries[Double],ln: Int): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td>ln:Int</td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>argMax</td><td>core.common.datastructures.NumericTimeSeries.argMax(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>argMin</td><td>core.common.datastructures.NumericTimeSeries.argMin(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>average</td><td>core.common.datastructures.NumericTimeSeries.average(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>averageOfLastK</td><td>core.common.datastructures.NumericTimeSeries.averageOfLastK(ts: core.common.datastructures.TimeSeries[Double],k: Int): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td>k:Int</td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>bimodalDelta</td><td>core.common.datastructures.NumericTimeSeries.bimodalDelta(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>derivativeSeries</td><td>core.common.datastructures.NumericTimeSeries.derivativeSeries(ts: core.common.datastructures.TimeSeries[Double]): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>derivativeSeriesPercentage</td><td>core.common.datastructures.NumericTimeSeries.derivativeSeriesPercentage(ts: core.common.datastructures.TimeSeries[Double]): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>dropTimeSeries</td><td>core.common.datastructures.NumericTimeSeries.dropTimeSeries(ts: core.common.datastructures.TimeSeries[Double],k: Int): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td>k:Int</td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>equalMassSample</td><td>core.common.datastructures.NumericTimeSeries.equalMassSample(ts: core.common.datastructures.TimeSeries[Double],size: Int,average: Boolean): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td>size:Int</td><td>average:Boolean</td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>exponentialMovingAverage</td><td>core.common.datastructures.NumericTimeSeries.exponentialMovingAverage(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>firstTimeOfAtLeast</td><td>core.common.datastructures.NumericTimeSeries.firstTimeOfAtLeast(ts: core.common.datastructures.TimeSeries[Double]): Seq[(Double,Double)]</td><td>Seq[(Double, Double)]</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>firstTimeOfAtMost</td><td>core.common.datastructures.NumericTimeSeries.firstTimeOfAtMost(ts: core.common.datastructures.TimeSeries[Double]): Seq[(Double,Double)]</td><td>Seq[(Double, Double)]</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>globalDelta</td><td>core.common.datastructures.NumericTimeSeries.globalDelta(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>globalTrend</td><td>core.common.datastructures.NumericTimeSeries.globalTrend(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>globalTrendSmoothed</td><td>core.common.datastructures.NumericTimeSeries.globalTrendSmoothed(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>gradientChanges</td><td>core.common.datastructures.NumericTimeSeries.gradientChanges(ts: core.common.datastructures.TimeSeries[Double]): Int</td><td>Int</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>integrate</td><td>core.common.datastructures.NumericTimeSeries.integrate(ts: core.common.datastructures.TimeSeries[Double]): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>lastDelta</td><td>core.common.datastructures.NumericTimeSeries.lastDelta(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>lastNumericLogDerivative</td><td>core.common.datastructures.NumericTimeSeries.lastNumericLogDerivative(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>lastRelativeSlope</td><td>core.common.datastructures.NumericTimeSeries.lastRelativeSlope(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>lastSlope</td><td>core.common.datastructures.NumericTimeSeries.lastSlope(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>lastTimeInterval</td><td>core.common.datastructures.NumericTimeSeries.lastTimeInterval(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>lastTimeOfAtLeast</td><td>core.common.datastructures.NumericTimeSeries.lastTimeOfAtLeast(ts: core.common.datastructures.TimeSeries[Double]): Seq[(Double,Double)]</td><td>Seq[(Double, Double)]</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>lastTimeOfAtMost</td><td>core.common.datastructures.NumericTimeSeries.lastTimeOfAtMost(ts: core.common.datastructures.TimeSeries[Double]): Seq[(Double,Double)]</td><td>Seq[(Double, Double)]</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>lastValue</td><td>core.common.datastructures.NumericTimeSeries.lastValue(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>maxRelative</td><td>core.common.datastructures.NumericTimeSeries.maxRelative(ts: core.common.datastructures.TimeSeries[Double]): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>maxRelativeDrawDown</td><td>core.common.datastructures.NumericTimeSeries.maxRelativeDrawDown(ts: core.common.datastructures.TimeSeries[Double]): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>maxSlope</td><td>core.common.datastructures.NumericTimeSeries.maxSlope(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>maxTimeInterval</td><td>core.common.datastructures.NumericTimeSeries.maxTimeInterval(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>maxY</td><td>core.common.datastructures.NumericTimeSeries.maxY(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>median</td><td>core.common.datastructures.NumericTimeSeries.median(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>minSlope</td><td>core.common.datastructures.NumericTimeSeries.minSlope(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>minTimeInterval</td><td>core.common.datastructures.NumericTimeSeries.minTimeInterval(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>minY</td><td>core.common.datastructures.NumericTimeSeries.minY(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>normalizedHistogram</td><td>core.common.datastructures.NumericTimeSeries.normalizedHistogram(ts: core.common.datastructures.TimeSeries[Double]): Seq[(Double,Double)]</td><td>Seq[(Double, Double)]</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>peaks</td><td>core.common.datastructures.NumericTimeSeries.peaks(ts: core.common.datastructures.TimeSeries[Double],topK: Int,smoothingWindowSize: Int): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td>topK:Int</td><td>smoothingWindowSize:Int</td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>positive</td><td>core.common.datastructures.NumericTimeSeries.positive(ts: core.common.datastructures.TimeSeries[Double]): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>rankOfLast</td><td>core.common.datastructures.NumericTimeSeries.rankOfLast(ts: core.common.datastructures.TimeSeries[Double]): Int</td><td>Int</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>secondArgMax</td><td>core.common.datastructures.NumericTimeSeries.secondArgMax(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>simpleSum</td><td>core.common.datastructures.NumericTimeSeries.simpleSum(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>smooth3</td><td>core.common.datastructures.NumericTimeSeries.smooth3(ts: core.common.datastructures.TimeSeries[Double]): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>softMax</td><td>core.common.datastructures.NumericTimeSeries.softMax(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>sortByValues</td><td>core.common.datastructures.NumericTimeSeries.sortByValues(ts: core.common.datastructures.TimeSeries[Double]): IndexedSeq[(Double,Double)]</td><td>IndexedSeq[(Double, Double)]</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>stddev</td><td>core.common.datastructures.NumericTimeSeries.stddev(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>sum</td><td>core.common.datastructures.NumericTimeSeries.sum(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>takeRightTimeSeries</td><td>core.common.datastructures.NumericTimeSeries.takeRightTimeSeries(ts: core.common.datastructures.TimeSeries[Double],k: Int): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td>k:Int</td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>topFrequency</td><td>core.common.datastructures.NumericTimeSeries.topFrequency(ts: core.common.datastructures.TimeSeries[Double]): (Double,Double)</td><td>(Double, Double)</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>tsDiff5</td><td>core.common.datastructures.NumericTimeSeries.tsDiff5(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>valueAt</td><td>core.common.datastructures.NumericTimeSeries.valueAt(ts: core.common.datastructures.TimeSeries[Double],time: Double): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td>time:Double</td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>valueRange</td><td>core.common.datastructures.NumericTimeSeries.valueRange(ts: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeries</td><td>withoutMinusOnes</td><td>core.common.datastructures.NumericTimeSeries.withoutMinusOnes(ts: core.common.datastructures.TimeSeries[Double]): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>ts:core.common.datastructures.TimeSeries[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeriesPairs</td><td>L2</td><td>core.common.datastructures.NumericTimeSeriesPairs.L2(a: core.common.datastructures.TimeSeries[Double],b: core.common.datastructures.TimeSeries[Double]): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>a:core.common.datastructures.TimeSeries[Double]</td><td>b:core.common.datastructures.TimeSeries[Double]</td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeriesPairs</td><td>areaBetween</td><td>core.common.datastructures.NumericTimeSeriesPairs.areaBetween(a: core.common.datastructures.TimeSeries[Double],b: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>a:core.common.datastructures.TimeSeries[Double]</td><td>b:core.common.datastructures.TimeSeries[Double]</td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeriesPairs</td><td>convolve</td><td>core.common.datastructures.NumericTimeSeriesPairs.convolve(a: core.common.datastructures.TimeSeries[Double],b: core.common.datastructures.TimeSeries[Double]): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>a:core.common.datastructures.TimeSeries[Double]</td><td>b:core.common.datastructures.TimeSeries[Double]</td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeriesPairs</td><td>correlation</td><td>core.common.datastructures.NumericTimeSeriesPairs.correlation(a: core.common.datastructures.TimeSeries[Double],b: core.common.datastructures.TimeSeries[Double]): Double</td><td>Double</td><td>a:core.common.datastructures.TimeSeries[Double]</td><td>b:core.common.datastructures.TimeSeries[Double]</td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeriesPairs</td><td>divide</td><td>core.common.datastructures.NumericTimeSeriesPairs.divide(a: core.common.datastructures.TimeSeries[Double],b: core.common.datastructures.TimeSeries[Double]): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>a:core.common.datastructures.TimeSeries[Double]</td><td>b:core.common.datastructures.TimeSeries[Double]</td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeriesPairs</td><td>max</td><td>core.common.datastructures.NumericTimeSeriesPairs.max(a: core.common.datastructures.TimeSeries[Double],b: core.common.datastructures.TimeSeries[Double]): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>a:core.common.datastructures.TimeSeries[Double]</td><td>b:core.common.datastructures.TimeSeries[Double]</td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeriesPairs</td><td>min</td><td>core.common.datastructures.NumericTimeSeriesPairs.min(a: core.common.datastructures.TimeSeries[Double],b: core.common.datastructures.TimeSeries[Double]): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>a:core.common.datastructures.TimeSeries[Double]</td><td>b:core.common.datastructures.TimeSeries[Double]</td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeriesPairs</td><td>minus</td><td>core.common.datastructures.NumericTimeSeriesPairs.minus(a: core.common.datastructures.TimeSeries[Double],b: core.common.datastructures.TimeSeries[Double]): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>a:core.common.datastructures.TimeSeries[Double]</td><td>b:core.common.datastructures.TimeSeries[Double]</td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeriesPairs</td><td>plus</td><td>core.common.datastructures.NumericTimeSeriesPairs.plus(a: core.common.datastructures.TimeSeries[Double],b: core.common.datastructures.TimeSeries[Double]): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>a:core.common.datastructures.TimeSeries[Double]</td><td>b:core.common.datastructures.TimeSeries[Double]</td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeriesPairs</td><td>pointwise</td><td>core.common.datastructures.NumericTimeSeriesPairs.pointwise(v1: IndexedSeq[Double],v2: IndexedSeq[Double]): IndexedSeq[Double]</td><td>IndexedSeq[Double]</td><td>v1:IndexedSeq[Double]</td><td>v2:IndexedSeq[Double]</td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeriesPairs</td><td>product</td><td>core.common.datastructures.NumericTimeSeriesPairs.product(a: core.common.datastructures.TimeSeries[Double],b: core.common.datastructures.TimeSeries[Double]): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>a:core.common.datastructures.TimeSeries[Double]</td><td>b:core.common.datastructures.TimeSeries[Double]</td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeriesPairs</td><td>reverse</td><td>core.common.datastructures.NumericTimeSeriesPairs.reverse(v: IndexedSeq[Double]): IndexedSeq[Double]</td><td>IndexedSeq[Double]</td><td>v:IndexedSeq[Double]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.NumericTimeSeriesPairs</td><td>simpleAvg</td><td>core.common.datastructures.NumericTimeSeriesPairs.simpleAvg(a: core.common.datastructures.TimeSeries[Double],b: core.common.datastructures.TimeSeries[Double]): core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>a:core.common.datastructures.TimeSeries[Double]</td><td>b:core.common.datastructures.TimeSeries[Double]</td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>aggregateByTimeFrame</td><td>core.common.datastructures.TimeSeries.aggregateByTimeFrame(tf: Double): core.common.datastructures.TimeSeries[T]</td><td>core.common.datastructures.TimeSeries[T]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td>tf:Double</td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>aggregateByTimeFrameDay</td><td>core.common.datastructures.TimeSeries.aggregateByTimeFrameDay: core.common.datastructures.TimeSeries[T]</td><td>core.common.datastructures.TimeSeries[T]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>aggregateByTimeFrameDayAsHours</td><td>core.common.datastructures.TimeSeries.aggregateByTimeFrameDayAsHours: core.common.datastructures.TimeSeries[T]</td><td>core.common.datastructures.TimeSeries[T]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>aggregateByTimeFrameDayAsMins</td><td>core.common.datastructures.TimeSeries.aggregateByTimeFrameDayAsMins: core.common.datastructures.TimeSeries[T]</td><td>core.common.datastructures.TimeSeries[T]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>aggregateByTimeFrameSpan$default$2</td><td>core.common.datastructures.TimeSeries.aggregateByTimeFrameSpan$default$2=&gt;Option[: Option[(Double,Double)]@scala.annotation.unchecked.uncheckedVariance</td><td>Option[(Double, Double)]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>aggregateByTimeFrameSpan</td><td>core.common.datastructures.TimeSeries.aggregateByTimeFrameSpan(tf: Double,forceMinMaxX: Option[(Double, Double)]): core.common.datastructures.TimeSeries[T]</td><td>core.common.datastructures.TimeSeries[T]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td>tf:Double</td><td>forceMinMaxX:Option[(Double, Double)]</td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>firstHalf</td><td>core.common.datastructures.TimeSeries.firstHalf: core.common.datastructures.TimeSeries[T]</td><td>core.common.datastructures.TimeSeries[T]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>firstPair</td><td>core.common.datastructures.TimeSeries.firstPair=&gt;: (java.util.Date,T)</td><td>(java.util.Date, T)</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>firstTimeOfValue</td><td>core.common.datastructures.TimeSeries.firstTimeOfValue=&gt;Seq[: Seq[(T,Double)]</td><td>Seq[(T, Double)]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>firstValue</td><td>core.common.datastructures.TimeSeries.firstValue: T</td><td>T</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>getValueAt</td><td>core.common.datastructures.TimeSeries.getValueAt(index: Int): T</td><td>T</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td>index:Int</td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>groupByY</td><td>core.common.datastructures.TimeSeries.groupByY=&gt;Seq[: Seq[(T,IndexedSeq[Double])]</td><td>Seq[(T, IndexedSeq[Double])]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>headOption</td><td>core.common.datastructures.TimeSeries.headOption=&gt;Iterable[: Iterable[(Double,T)]</td><td>Iterable[(Double, T)]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>headX</td><td>core.common.datastructures.TimeSeries.headX: Double</td><td>Double</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>histogramOfHours</td><td>core.common.datastructures.TimeSeries.histogramOfHours=&gt;Seq[: Seq[(Int,Double)]</td><td>Seq[(Int, Double)]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>histogramY</td><td>core.common.datastructures.TimeSeries.histogramY=&gt;Seq[: Seq[(T,Double)]</td><td>Seq[(T, Double)]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>inDateWindow$default$3</td><td>core.common.datastructures.TimeSeries.inDateWindow$default$3: Boolean@scala.annotation.unchecked.uncheckedVariance</td><td>Boolean</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>inDateWindow</td><td>core.common.datastructures.TimeSeries.inDateWindow(from: java.util.Date,to: java.util.Date,includeUntil: Boolean): core.common.datastructures.TimeSeries[T]</td><td>core.common.datastructures.TimeSeries[T]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td>from:java.util.Date</td><td>to:java.util.Date</td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>inWindow$default$3</td><td>core.common.datastructures.TimeSeries.inWindow$default$3: Boolean@scala.annotation.unchecked.uncheckedVariance</td><td>Boolean</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>inWindow</td><td>core.common.datastructures.TimeSeries.inWindow(from: Double,to: Double,includeUntil: Boolean): core.common.datastructures.TimeSeries[T]</td><td>core.common.datastructures.TimeSeries[T]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td>from:Double</td><td>to:Double</td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>intervals</td><td>core.common.datastructures.TimeSeries.intervals: core.common.datastructures.TimeSeries[Double]</td><td>core.common.datastructures.TimeSeries[Double]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>isEmpty</td><td>core.common.datastructures.TimeSeries.isEmpty: Boolean</td><td>Boolean</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>lastOption</td><td>core.common.datastructures.TimeSeries.lastOption=&gt;Iterable[: Iterable[(Double,T)]</td><td>Iterable[(Double, T)]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>lastPair</td><td>core.common.datastructures.TimeSeries.lastPair=&gt;: (java.util.Date,T)</td><td>(java.util.Date, T)</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>lastTimeOfValue</td><td>core.common.datastructures.TimeSeries.lastTimeOfValue=&gt;Seq[: Seq[(T,Double)]</td><td>Seq[(T, Double)]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>lastValue</td><td>core.common.datastructures.TimeSeries.lastValue: T</td><td>T</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>lastX</td><td>core.common.datastructures.TimeSeries.lastX: Double</td><td>Double</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>length</td><td>core.common.datastructures.TimeSeries.length: Int</td><td>Int</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>nonEmpty</td><td>core.common.datastructures.TimeSeries.nonEmpty: Boolean</td><td>Boolean</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>pairFrequencies</td><td>core.common.datastructures.TimeSeries.pairFrequencies=&gt;Seq[: Seq[((Double,T),Double)]</td><td>Seq[((Double, T), Double)]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>removeOffset</td><td>core.common.datastructures.TimeSeries.removeOffset: core.common.datastructures.TimeSeries[T]</td><td>core.common.datastructures.TimeSeries[T]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>secondHalf</td><td>core.common.datastructures.TimeSeries.secondHalf: core.common.datastructures.TimeSeries[T]</td><td>core.common.datastructures.TimeSeries[T]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>timesOfYaggregateDay</td><td>core.common.datastructures.TimeSeries.timesOfYaggregateDay=&gt;Seq[: Seq[((Double,T),Double)]</td><td>Seq[((Double, T), Double)]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>timesOfYaggregateDayAsHours</td><td>core.common.datastructures.TimeSeries.timesOfYaggregateDayAsHours=&gt;Seq[: Seq[((Double,T),Double)]</td><td>Seq[((Double, T), Double)]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>timesOfYaggregateDayAsMins</td><td>core.common.datastructures.TimeSeries.timesOfYaggregateDayAsMins=&gt;Seq[: Seq[((Double,T),Double)]</td><td>Seq[((Double, T), Double)]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>y</td><td>core.common.datastructures.TimeSeries.y: IndexedSeq[T]</td><td>IndexedSeq[T]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.datastructures.TimeSeries</td><td>zipped</td><td>core.common.datastructures.TimeSeries.zipped=&gt;IndexedSeq[: IndexedSeq[(Double,T)]</td><td>IndexedSeq[(Double, T)]</td><td>TimeSeries:core.common.datastructures.TimeSeries[T]</td><td></td><td></td></tr>
<tr><td>core.common.zeroComplexity.CustomGraphFunctions</td><td>distanceBetween</td><td>core.common.zeroComplexity.CustomGraphFunctions.distanceBetween(key1: Any,key2: Any,geoCustomGraph: core.Solving.provider.CustomGraphGeo): Double</td><td>Double</td><td>key1:Any</td><td>key2:Any</td><td>geoCustomGraph:core.Solving.provider.CustomGraphGeo</td></tr>
<tr><td>core.common.zeroComplexity.CustomGraphFunctions</td><td>info</td><td>core.common.zeroComplexity.CustomGraphFunctions.info(key: Any,customGraph: core.Solving.provider.CustomGraphTrait): Map[String,String]</td><td>Map[String,String]</td><td>key:Any</td><td>customGraph:core.Solving.provider.CustomGraphTrait</td><td></td></tr>
<tr><td>core.common.zeroComplexity.CustomGraphFunctions</td><td>latLong</td><td>core.common.zeroComplexity.CustomGraphFunctions.latLong(key: Any,geoCustomGraph: core.Solving.provider.CustomGraphGeo): core.datastructures.LatLong</td><td>core.datastructures.LatLong</td><td>key:Any</td><td>geoCustomGraph:core.Solving.provider.CustomGraphGeo</td><td></td></tr>
<tr><td>core.common.zeroComplexity.CustomGraphFunctions</td><td>latitude</td><td>core.common.zeroComplexity.CustomGraphFunctions.latitude(key: Any,geoCustomGraph: core.Solving.provider.CustomGraphGeo): Double</td><td>Double</td><td>key:Any</td><td>geoCustomGraph:core.Solving.provider.CustomGraphGeo</td><td></td></tr>
<tr><td>core.common.zeroComplexity.CustomGraphFunctions</td><td>longitude</td><td>core.common.zeroComplexity.CustomGraphFunctions.longitude(key: Any,geoCustomGraph: core.Solving.provider.CustomGraphGeo): Double</td><td>Double</td><td>key:Any</td><td>geoCustomGraph:core.Solving.provider.CustomGraphGeo</td><td></td></tr>
<tr><td>core.common.zeroComplexity.CustomGraphFunctions</td><td>numericInfo</td><td>core.common.zeroComplexity.CustomGraphFunctions.numericInfo(key: Any,customGraph: core.Solving.provider.CustomGraphTrait): Map[String,Double]</td><td>Map[String,Double]</td><td>key:Any</td><td>customGraph:core.Solving.provider.CustomGraphTrait</td><td></td></tr>
<tr><td>core.common.zeroComplexity.ZeroComplexityFunctions</td><td>count</td><td>core.common.zeroComplexity.ZeroComplexityFunctions.count[T](value: T,collection: Iterable[T]): Int</td><td>Int</td><td>value:T</td><td>collection:Iterable[T]</td><td></td></tr>
<tr><td>core.common.zeroComplexity.ZeroComplexityFunctions</td><td>distMoment</td><td>core.common.zeroComplexity.ZeroComplexityFunctions.distMoment(points: Seq[Double],point: Double): Double</td><td>Double</td><td>points:Seq[Double]</td><td>point:Double</td><td></td></tr>
<tr><td>core.common.zeroComplexity.ZeroComplexityFunctions</td><td>distMomentLatLong</td><td>core.common.zeroComplexity.ZeroComplexityFunctions.distMomentLatLong(points: Seq[core.datastructures.LatLong],point: core.datastructures.LatLong): Double</td><td>Double</td><td>points:Seq[core.datastructures.LatLong]</td><td>point:core.datastructures.LatLong</td><td></td></tr>
<tr><td>core.common.zeroComplexity.ZeroComplexityFunctions</td><td>distanceFromClosest</td><td>core.common.zeroComplexity.ZeroComplexityFunctions.distanceFromClosest(points: Seq[core.datastructures.LatLong],point: core.datastructures.LatLong): Double</td><td>Double</td><td>points:Seq[core.datastructures.LatLong]</td><td>point:core.datastructures.LatLong</td><td></td></tr>
<tr><td>core.common.zeroComplexity.ZeroComplexityFunctions</td><td>isOneOf</td><td>core.common.zeroComplexity.ZeroComplexityFunctions.isOneOf(value: Any,subset: core.datastructures.SmallCollection): Boolean</td><td>Boolean</td><td>value:Any</td><td>subset:core.datastructures.SmallCollection</td><td></td></tr>
<tr><td>core.common.zeroComplexity.ZeroComplexityFunctions</td><td>percentile</td><td>core.common.zeroComplexity.ZeroComplexityFunctions.percentile(value: Double,collection: Iterable[Double]): Double</td><td>Double</td><td>value:Double</td><td>collection:Iterable[Double]</td><td></td></tr>
<tr><td>core.common.zeroComplexity.ZeroComplexityFunctions</td><td>seqToTextList</td><td>core.common.zeroComplexity.ZeroComplexityFunctions.seqToTextList(seq: Seq[core.nlp.Text]): core.datastructures.graph.traversal.ExtendedPredicateswithcore.nlp.SemanticWrapper</td><td>core.datastructures.graph.traversal.ExtendedPredicates with core.nlp.SemanticWrapper</td><td>seq:Seq[core.nlp.Text]</td><td></td><td></td></tr>
<tr><td>core.common.zeroComplexity.ZeroComplexityFunctions</td><td>timeSeriesToTextList</td><td>core.common.zeroComplexity.ZeroComplexityFunctions.timeSeriesToTextList(timeSeries: core.common.datastructures.TimeSeries[core.nlp.Text]): core.nlp.TextList</td><td>core.nlp.TextList</td><td>timeSeries:core.common.datastructures.TimeSeries[core.nlp.Text]</td><td></td><td></td></tr>
<tr><td>core.common.zeroComplexity.ZeroComplexityFunctions</td><td>uniqueness</td><td>core.common.zeroComplexity.ZeroComplexityFunctions.uniqueness(text: core.nlp.Text,textHist: core.common.datastructures.TextIndex): Double</td><td>Double</td><td>text:core.nlp.Text</td><td>textHist:core.common.datastructures.TextIndex</td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>dateToDouble</td><td>core.datastructures.DateHelper.dateToDouble(date: java.util.Date): Double</td><td>Double</td><td>date:java.util.Date</td><td></td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>dayOfMonth</td><td>core.datastructures.DateHelper.dayOfMonth(dateTime: java.util.Date): Int</td><td>Int</td><td>dateTime:java.util.Date</td><td></td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>dayOfWeek</td><td>core.datastructures.DateHelper.dayOfWeek(dateTime: java.util.Date): Int</td><td>Int</td><td>dateTime:java.util.Date</td><td></td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>diffDays</td><td>core.datastructures.DateHelper.diffDays(dateTime: java.util.Date,dw: java.util.Date): Int</td><td>Int</td><td>dateTime:java.util.Date</td><td>dw:java.util.Date</td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>diffHours</td><td>core.datastructures.DateHelper.diffHours(dateTime: java.util.Date,dw: java.util.Date): Int</td><td>Int</td><td>dateTime:java.util.Date</td><td>dw:java.util.Date</td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>diffMinutes</td><td>core.datastructures.DateHelper.diffMinutes(dateTime: java.util.Date,dw: java.util.Date): Int</td><td>Int</td><td>dateTime:java.util.Date</td><td>dw:java.util.Date</td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>diffMonths</td><td>core.datastructures.DateHelper.diffMonths(dateTime: java.util.Date,dw: java.util.Date): Int</td><td>Int</td><td>dateTime:java.util.Date</td><td>dw:java.util.Date</td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>diffWeeks</td><td>core.datastructures.DateHelper.diffWeeks(dateTime: java.util.Date,dw: java.util.Date): Int</td><td>Int</td><td>dateTime:java.util.Date</td><td>dw:java.util.Date</td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>diffYears</td><td>core.datastructures.DateHelper.diffYears(dateTime: java.util.Date,dw: java.util.Date): Int</td><td>Int</td><td>dateTime:java.util.Date</td><td>dw:java.util.Date</td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>floorToDay</td><td>core.datastructures.DateHelper.floorToDay(d: java.util.Date): java.util.Date</td><td>java.util.Date</td><td>d:java.util.Date</td><td></td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>floorToMonth</td><td>core.datastructures.DateHelper.floorToMonth(d: java.util.Date): java.util.Date</td><td>java.util.Date</td><td>d:java.util.Date</td><td></td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>floorToWeek</td><td>core.datastructures.DateHelper.floorToWeek(d: java.util.Date): java.util.Date</td><td>java.util.Date</td><td>d:java.util.Date</td><td></td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>fromJoda</td><td>core.datastructures.DateHelper.fromJoda(d: org.joda.time.DateTime): java.util.Date</td><td>java.util.Date</td><td>d:org.joda.time.DateTime</td><td></td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>hourOfDay</td><td>core.datastructures.DateHelper.hourOfDay(dateTime: java.util.Date): Int</td><td>Int</td><td>dateTime:java.util.Date</td><td></td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>isAfter</td><td>core.datastructures.DateHelper.isAfter(a: java.util.Date,b: java.util.Date): Boolean</td><td>Boolean</td><td>a:java.util.Date</td><td>b:java.util.Date</td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>isAfterString</td><td>core.datastructures.DateHelper.isAfterString(a: java.util.Date,b: String): Boolean</td><td>Boolean</td><td>a:java.util.Date</td><td>b:String</td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>isBefore</td><td>core.datastructures.DateHelper.isBefore(a: java.util.Date,b: java.util.Date): Boolean</td><td>Boolean</td><td>a:java.util.Date</td><td>b:java.util.Date</td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>isBeforeString</td><td>core.datastructures.DateHelper.isBeforeString(a: java.util.Date,b: String): Boolean</td><td>Boolean</td><td>a:java.util.Date</td><td>b:String</td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>isEmpty</td><td>core.datastructures.DateHelper.isEmpty(a: java.util.Date): Boolean</td><td>Boolean</td><td>a:java.util.Date</td><td></td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>isEvening</td><td>core.datastructures.DateHelper.isEvening(d: java.util.Date): Boolean</td><td>Boolean</td><td>d:java.util.Date</td><td></td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>isLunch</td><td>core.datastructures.DateHelper.isLunch(d: java.util.Date): Boolean</td><td>Boolean</td><td>d:java.util.Date</td><td></td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>isMorning</td><td>core.datastructures.DateHelper.isMorning(d: java.util.Date): Boolean</td><td>Boolean</td><td>d:java.util.Date</td><td></td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>isNight</td><td>core.datastructures.DateHelper.isNight(d: java.util.Date): Boolean</td><td>Boolean</td><td>d:java.util.Date</td><td></td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>isWeekend1</td><td>core.datastructures.DateHelper.isWeekend1(d: java.util.Date): Boolean</td><td>Boolean</td><td>d:java.util.Date</td><td></td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>isWeekend2</td><td>core.datastructures.DateHelper.isWeekend2(d: java.util.Date): Boolean</td><td>Boolean</td><td>d:java.util.Date</td><td></td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>isWorkTime</td><td>core.datastructures.DateHelper.isWorkTime(d: java.util.Date): Boolean</td><td>Boolean</td><td>d:java.util.Date</td><td></td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>minusDate</td><td>core.datastructures.DateHelper.minusDate(d: java.util.Date,ref: java.util.Date): org.joda.time.DateTime</td><td>org.joda.time.DateTime</td><td>d:java.util.Date</td><td>ref:java.util.Date</td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>minusDate</td><td>core.datastructures.DateHelper.minusDate(d: java.util.Date,ref: org.joda.time.DateTime): java.util.Date</td><td>java.util.Date</td><td>d:java.util.Date</td><td>ref:org.joda.time.DateTime</td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>monthOfYear</td><td>core.datastructures.DateHelper.monthOfYear(dateTime: java.util.Date): Int</td><td>Int</td><td>dateTime:java.util.Date</td><td></td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>partOfDay</td><td>core.datastructures.DateHelper.partOfDay(d: java.util.Date): Char</td><td>Char</td><td>d:java.util.Date</td><td></td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>toJoda</td><td>core.datastructures.DateHelper.toJoda(d: java.util.Date): org.joda.time.DateTime</td><td>org.joda.time.DateTime</td><td>d:java.util.Date</td><td></td><td></td></tr>
<tr><td>core.datastructures.DateHelper</td><td>year</td><td>core.datastructures.DateHelper.year(date: java.util.Date): Int</td><td>Int</td><td>date:java.util.Date</td><td></td><td></td></tr>
<tr><td>core.datastructures.Histogram</td><td>$plus$eq</td><td>core.datastructures.Histogram.$plus$eq(key: A): Double</td><td>Double</td><td>Histogram:core.datastructures.Histogram[A]</td><td>key:A</td><td></td></tr>
<tr><td>core.datastructures.Histogram</td><td>apply</td><td>core.datastructures.Histogram.apply[A](pairs: Iterable[(A, Double)]): core.datastructures.Histogram[A]</td><td>core.datastructures.Histogram[A]</td><td>pairs:Iterable[(A, Double)]</td><td></td><td></td></tr>
<tr><td>core.datastructures.Histogram</td><td>bimodalRatio</td><td>core.datastructures.Histogram.bimodalRatio: Double</td><td>Double</td><td>Histogram:core.datastructures.Histogram[A]</td><td></td><td></td></tr>
<tr><td>core.datastructures.Histogram</td><td>entropy</td><td>core.datastructures.Histogram.entropy: Double</td><td>Double</td><td>Histogram:core.datastructures.Histogram[A]</td><td></td><td></td></tr>
<tr><td>core.datastructures.Histogram</td><td>increment$default$2</td><td>core.datastructures.Histogram.increment$default$2: Double@scala.annotation.unchecked.uncheckedVariance</td><td>Double</td><td>Histogram:core.datastructures.Histogram[A]</td><td></td><td></td></tr>
<tr><td>core.datastructures.Histogram</td><td>increment</td><td>core.datastructures.Histogram.increment(key: A,by: Double): Double</td><td>Double</td><td>Histogram:core.datastructures.Histogram[A]</td><td>key:A</td><td>by:Double</td></tr>
<tr><td>core.datastructures.Histogram</td><td>mode</td><td>core.datastructures.Histogram.mode: A</td><td>A</td><td>Histogram:core.datastructures.Histogram[A]</td><td></td><td></td></tr>
<tr><td>core.datastructures.Histogram</td><td>normalize</td><td>core.datastructures.Histogram.normalize=&gt;Seq[: Seq[(A,Double)]</td><td>Seq[(A, Double)]</td><td>Histogram:core.datastructures.Histogram[A]</td><td></td><td></td></tr>
<tr><td>core.datastructures.Histogram</td><td>range</td><td>core.datastructures.Histogram.range: Double</td><td>Double</td><td>Histogram:core.datastructures.Histogram[A]</td><td></td><td></td></tr>
<tr><td>core.datastructures.Histogram</td><td>secondMode</td><td>core.datastructures.Histogram.secondMode: A</td><td>A</td><td>Histogram:core.datastructures.Histogram[A]</td><td></td><td></td></tr>
<tr><td>core.datastructures.Histogram</td><td>sum</td><td>core.datastructures.Histogram.sum: Double</td><td>Double</td><td>Histogram:core.datastructures.Histogram[A]</td><td></td><td></td></tr>
<tr><td>core.datastructures.Histogram</td><td>top</td><td>core.datastructures.Histogram.top(n: Int): Seq[(A,Double)]</td><td>Seq[(A, Double)]</td><td>Histogram:core.datastructures.Histogram[A]</td><td>n:Int</td><td></td></tr>
<tr><td>core.datastructures.LatLong</td><td>copy</td><td>core.datastructures.LatLong.copy(latitude: Double,longitude: Double): core.datastructures.LatLong</td><td>core.datastructures.LatLong</td><td>LatLong:core.datastructures.LatLong</td><td>latitude:Double</td><td>longitude:Double</td></tr>
<tr><td>core.datastructures.LatLong</td><td>distanceFrom</td><td>core.datastructures.LatLong.distanceFrom(other: core.datastructures.LatLong): Double</td><td>Double</td><td>LatLong:core.datastructures.LatLong</td><td>other:core.datastructures.LatLong</td><td></td></tr>
<tr><td>core.datastructures.LatLong</td><td>latLong0</td><td>core.datastructures.LatLong.latLong0: core.datastructures.LatLong</td><td>core.datastructures.LatLong</td><td>LatLong:core.datastructures.LatLong</td><td></td><td></td></tr>
<tr><td>core.datastructures.LatLong</td><td>latLong1</td><td>core.datastructures.LatLong.latLong1: core.datastructures.LatLong</td><td>core.datastructures.LatLong</td><td>LatLong:core.datastructures.LatLong</td><td></td><td></td></tr>
<tr><td>core.datastructures.LatLong</td><td>latLong2</td><td>core.datastructures.LatLong.latLong2: core.datastructures.LatLong</td><td>core.datastructures.LatLong</td><td>LatLong:core.datastructures.LatLong</td><td></td><td></td></tr>
<tr><td>core.datastructures.LatLong</td><td>latLong3</td><td>core.datastructures.LatLong.latLong3: core.datastructures.LatLong</td><td>core.datastructures.LatLong</td><td>LatLong:core.datastructures.LatLong</td><td></td><td></td></tr>
<tr><td>core.datastructures.LatLong</td><td>latitude</td><td>core.datastructures.LatLong.latitude: Double</td><td>Double</td><td>LatLong:core.datastructures.LatLong</td><td></td><td></td></tr>
<tr><td>core.datastructures.LatLong</td><td>longitude</td><td>core.datastructures.LatLong.longitude: Double</td><td>Double</td><td>LatLong:core.datastructures.LatLong</td><td></td><td></td></tr>
<tr><td>core.datastructures.LexiconHelper</td><td>countFromDictionary</td><td>core.datastructures.LexiconHelper.countFromDictionary(tokens: core.nlp.TokensList,lexicon: core.datastructures.Lexicon): Int</td><td>Int</td><td>tokens:core.nlp.TokensList</td><td>lexicon:core.datastructures.Lexicon</td><td></td></tr>
<tr><td>core.datastructures.PreAggregation</td><td>lookup</td><td>core.datastructures.PreAggregation.lookup(agg: core.datastructures.Dictionary[Any,Int],lookupVal: Any): Int</td><td>Int</td><td>agg:core.datastructures.Dictionary[Any,Int]</td><td>lookupVal:Any</td><td></td></tr>
<tr><td>core.datastructures.PreAggregationDouble</td><td>lookup</td><td>core.datastructures.PreAggregationDouble.lookup(agg: core.datastructures.Dictionary[Any,Double],lookupVal: Any): Double</td><td>Double</td><td>agg:core.datastructures.Dictionary[Any,Double]</td><td>lookupVal:Any</td><td></td></tr>
<tr><td>core.datastructures.PreAggregationString</td><td>lookup</td><td>core.datastructures.PreAggregationString.lookup(agg: core.datastructures.Dictionary[String,String],lookupVal: String): String</td><td>String</td><td>agg:core.datastructures.Dictionary[String,String]</td><td>lookupVal:String</td><td></td></tr>
<tr><td>core.datastructures.URLList</td><td>containsDateSegments</td><td>core.datastructures.URLList.containsDateSegments(urls: Seq[core.datastructures.CBURL]): Seq[Boolean]</td><td>Seq[Boolean]</td><td>urls:Seq[core.datastructures.CBURL]</td><td></td><td></td></tr>
<tr><td>core.datastructures.URLList</td><td>host2</td><td>core.datastructures.URLList.host2(urls: Seq[core.datastructures.CBURL]): Seq[String]</td><td>Seq[String]</td><td>urls:Seq[core.datastructures.CBURL]</td><td></td><td></td></tr>
<tr><td>core.datastructures.URLList</td><td>hosts</td><td>core.datastructures.URLList.hosts(urls: Seq[core.datastructures.CBURL]): Seq[String]</td><td>Seq[String]</td><td>urls:Seq[core.datastructures.CBURL]</td><td></td><td></td></tr>
<tr><td>core.datastructures.URLList</td><td>numericQueryPartsMap</td><td>core.datastructures.URLList.numericQueryPartsMap(urls: Seq[core.datastructures.CBURL]): Seq[(String,Double)]</td><td>Seq[(String, Double)]</td><td>urls:Seq[core.datastructures.CBURL]</td><td></td><td></td></tr>
<tr><td>core.datastructures.URLList</td><td>paths</td><td>core.datastructures.URLList.paths(urls: Seq[core.datastructures.CBURL]): Seq[String]</td><td>Seq[String]</td><td>urls:Seq[core.datastructures.CBURL]</td><td></td><td></td></tr>
<tr><td>core.datastructures.URLList</td><td>port</td><td>core.datastructures.URLList.port(urls: Seq[core.datastructures.CBURL]): Seq[Int]</td><td>Seq[Int]</td><td>urls:Seq[core.datastructures.CBURL]</td><td></td><td></td></tr>
<tr><td>core.datastructures.URLList</td><td>protocols</td><td>core.datastructures.URLList.protocols(urls: Seq[core.datastructures.CBURL]): Seq[String]</td><td>Seq[String]</td><td>urls:Seq[core.datastructures.CBURL]</td><td></td><td></td></tr>
<tr><td>core.datastructures.URLList</td><td>queries</td><td>core.datastructures.URLList.queries(urls: Seq[core.datastructures.CBURL]): Seq[Char]</td><td>Seq[Char]</td><td>urls:Seq[core.datastructures.CBURL]</td><td></td><td></td></tr>
<tr><td>core.datastructures.URLList</td><td>queryPartsMap</td><td>core.datastructures.URLList.queryPartsMap(urls: Seq[core.datastructures.CBURL]): Seq[(String,String)]</td><td>Seq[(String, String)]</td><td>urls:Seq[core.datastructures.CBURL]</td><td></td><td></td></tr>
<tr><td>core.datastructures.URLList</td><td>tokens</td><td>core.datastructures.URLList.tokens(urls: Seq[core.datastructures.CBURL]): core.nlp.TokensList</td><td>core.nlp.TokensList</td><td>urls:Seq[core.datastructures.CBURL]</td><td></td><td></td></tr>
<tr><td>core.datastructures.URLList</td><td>tokensByDict</td><td>core.datastructures.URLList.tokensByDict(urls: Seq[core.datastructures.CBURL]): core.nlp.TokensList</td><td>core.nlp.TokensList</td><td>urls:Seq[core.datastructures.CBURL]</td><td></td><td></td></tr>
<tr><td>core.datastructures.URLList</td><td>withoutQuery</td><td>core.datastructures.URLList.withoutQuery(urls: Seq[core.datastructures.CBURL]): Seq[String]</td><td>Seq[String]</td><td>urls:Seq[core.datastructures.CBURL]</td><td></td><td></td></tr>
<tr><td>core.datastructures.Zipcode</td><td>apply</td><td>core.datastructures.Zipcode.apply(zipcode: String): core.datastructures.Zipcode</td><td>core.datastructures.Zipcode</td><td>zipcode:String</td><td></td><td></td></tr>
<tr><td>core.datastructures.Zipcode</td><td>copy</td><td>core.datastructures.Zipcode.copy(zipcode: String): core.datastructures.Zipcode</td><td>core.datastructures.Zipcode</td><td>Zipcode:core.datastructures.Zipcode</td><td>zipcode:String</td><td></td></tr>
<tr><td>core.datastructures.Zipcode</td><td>zipcode</td><td>core.datastructures.Zipcode.zipcode: String</td><td>String</td><td>Zipcode:core.datastructures.Zipcode</td><td></td><td></td></tr>
<tr><td>core.datastructures.graph.LanguageGraphWrapper</td><td>allHypernyms</td><td>core.datastructures.graph.LanguageGraphWrapper.allHypernyms(label: core.nlp.Token): core.datastructures.graph.traversal.NodeList</td><td>core.datastructures.graph.traversal.NodeList</td><td>label:core.nlp.Token</td><td></td><td></td></tr>
<tr><td>core.datastructures.graph.LanguageGraphWrapper</td><td>nodeListFromConcept</td><td>core.datastructures.graph.LanguageGraphWrapper.nodeListFromConcept(string: String,typHints: Option[Seq[Int]]): core.datastructures.graph.traversal.NodeList</td><td>core.datastructures.graph.traversal.NodeList</td><td>string:String</td><td>typHints:Option[Seq[Int]]</td><td></td></tr>
<tr><td>core.datastructures.graph.LanguageGraphWrapper</td><td>nodeListFromTokens</td><td>core.datastructures.graph.LanguageGraphWrapper.nodeListFromTokens(tokenList: Iterable[core.nlp.Token],typHints: Option[Seq[Int]]): core.datastructures.graph.traversal.NodeList</td><td>core.datastructures.graph.traversal.NodeList</td><td>tokenList:Iterable[core.nlp.Token]</td><td>typHints:Option[Seq[Int]]</td><td></td></tr>
<tr><td>core.datastructures.graph.traversal.AllEdges</td><td>numericEdges</td><td>core.datastructures.graph.traversal.AllEdges.numericEdges: Seq[core.datastructures.graph.HalfEdge[Double]]</td><td>Seq[core.datastructures.graph.HalfEdge[Double]]</td><td>AllEdges:core.datastructures.graph.traversal.AllEdges</td><td></td><td></td></tr>
<tr><td>core.datastructures.graph.traversal.AllEdges</td><td>relatedTo</td><td>core.datastructures.graph.traversal.AllEdges.relatedTo: Seq[Any]</td><td>Seq[Any]</td><td>AllEdges:core.datastructures.graph.traversal.AllEdges</td><td></td><td></td></tr>
<tr><td>core.datastructures.graph.traversal.ExtendedPredicates</td><td>hypernymClosure</td><td>core.datastructures.graph.traversal.ExtendedPredicates.hypernymClosure: core.datastructures.graph.traversal.NodeList</td><td>core.datastructures.graph.traversal.NodeList</td><td>ExtendedPredicates:core.datastructures.graph.traversal.ExtendedPredicates</td><td></td><td></td></tr>
<tr><td>core.datastructures.graph.traversal.ExtendedPredicates</td><td>latLongs</td><td>core.datastructures.graph.traversal.ExtendedPredicates.latLongs: Seq[core.datastructures.LatLong]</td><td>Seq[core.datastructures.LatLong]</td><td>ExtendedPredicates:core.datastructures.graph.traversal.ExtendedPredicates</td><td></td><td></td></tr>
<tr><td>core.datastructures.graph.traversal.ExtendedPredicates</td><td>workSubj</td><td>core.datastructures.graph.traversal.ExtendedPredicates.workSubj: core.datastructures.graph.traversal.NodeList</td><td>core.datastructures.graph.traversal.NodeList</td><td>ExtendedPredicates:core.datastructures.graph.traversal.ExtendedPredicates</td><td></td><td></td></tr>
<tr><td>core.datastructures.graph.traversal.NodeFrontTrait</td><td>expand</td><td>core.datastructures.graph.traversal.NodeFrontTrait.expand: core.datastructures.graph.traversal.NodeFront</td><td>core.datastructures.graph.traversal.NodeFront</td><td>NodeFrontTrait:core.datastructures.graph.traversal.NodeFrontTrait</td><td></td><td></td></tr>
<tr><td>core.datastructures.graph.traversal.NodeFrontTrait</td><td>expandForward</td><td>core.datastructures.graph.traversal.NodeFrontTrait.expandForward: core.datastructures.graph.traversal.NodeFront</td><td>core.datastructures.graph.traversal.NodeFront</td><td>NodeFrontTrait:core.datastructures.graph.traversal.NodeFrontTrait</td><td></td><td></td></tr>
<tr><td>core.datastructures.graph.traversal.NodeFrontTrait</td><td>numericProperties</td><td>core.datastructures.graph.traversal.NodeFrontTrait.numericProperties=&gt;core.common.datastructures.LazySeq[: core.common.datastructures.LazySeq[(List[String],Double)]</td><td>core.common.datastructures.LazySeq[(List[String], Double)]</td><td>NodeFrontTrait:core.datastructures.graph.traversal.NodeFrontTrait</td><td></td><td></td></tr>
<tr><td>core.datastructures.graph.traversal.WeightedNodeFront</td><td>apply</td><td>core.datastructures.graph.traversal.WeightedNodeFront.apply(front: core.common.datastructures.LazySeq[(core.datastructures.graph.traversal.NodePath, Double)]): core.datastructures.graph.traversal.WeightedNodeFront</td><td>core.datastructures.graph.traversal.WeightedNodeFront</td><td>front:core.common.datastructures.LazySeq[(core.datastructures.graph.traversal.NodePath, Double)]</td><td></td><td></td></tr>
<tr><td>core.datastructures.graph.traversal.WeightedNodeFront</td><td>expandTuplesForward</td><td>core.datastructures.graph.traversal.WeightedNodeFront.expandTuplesForward(map: Iterable[(core.nlp.TextPredicates, Double)]): core.common.datastructures.LazySeq[(core.datastructures.graph.traversal.NodePath,Double)]</td><td>core.common.datastructures.LazySeq[(core.datastructures.graph.traversal.NodePath, Double)]</td><td>map:Iterable[(core.nlp.TextPredicates, Double)]</td><td></td><td></td></tr>
<tr><td>core.datastructures.graph.traversal.WeightedNodeFront</td><td>numericProperties</td><td>core.datastructures.graph.traversal.WeightedNodeFront.numericProperties(map: Iterable[(core.nlp.TextPredicates, Double)]): core.common.datastructures.LazySeq[(List[String],Double)]</td><td>core.common.datastructures.LazySeq[(List[String], Double)]</td><td>map:Iterable[(core.nlp.TextPredicates, Double)]</td><td></td><td></td></tr>
<tr><td>core.datastructures.graph.traversal.WeightedNodeFront</td><td>ofConcepts</td><td>core.datastructures.graph.traversal.WeightedNodeFront.ofConcepts(map: Iterable[(core.nlp.TextPredicates, Double)]): core.datastructures.graph.traversal.WeightedNodeFront</td><td>core.datastructures.graph.traversal.WeightedNodeFront</td><td>map:Iterable[(core.nlp.TextPredicates, Double)]</td><td></td><td></td></tr>
<tr><td>core.nlp.GeoConcept</td><td>typHints</td><td>core.nlp.GeoConcept.typHints: Option[Seq[core.datastructures.graph.node.ResourceNode]]</td><td>Option[Seq[core.datastructures.graph.node.ResourceNode]]</td><td>GeoConcept:core.nlp.GeoConcept</td><td></td><td></td></tr>
<tr><td>core.nlp.HasLatLongs</td><td>distanceFrom</td><td>core.nlp.HasLatLongs.distanceFrom(other: core.nlp.HasLatLongs): Double</td><td>Double</td><td>HasLatLongs:core.nlp.HasLatLongs</td><td>other:core.nlp.HasLatLongs</td><td></td></tr>
<tr><td>core.nlp.HasLatLongs</td><td>latLongs</td><td>core.nlp.HasLatLongs.latLongs: Seq[core.datastructures.LatLong]</td><td>Seq[core.datastructures.LatLong]</td><td>HasLatLongs:core.nlp.HasLatLongs</td><td></td><td></td></tr>
<tr><td>core.nlp.LatLongConcept</td><td>apply</td><td>core.nlp.LatLongConcept.apply(string: String,typHints: Option[Seq[core.datastructures.graph.node.ResourceNode]]): core.nlp.LatLongConcept</td><td>core.nlp.LatLongConcept</td><td>string:String</td><td>typHints:Option[Seq[core.datastructures.graph.node.ResourceNode]]</td><td></td></tr>
<tr><td>core.nlp.LatLongConcept</td><td>copy</td><td>core.nlp.LatLongConcept.copy(string: String,typHints: Option[Seq[core.datastructures.graph.node.ResourceNode]]): core.nlp.LatLongConcept</td><td>core.nlp.LatLongConcept</td><td>LatLongConcept:core.nlp.LatLongConcept</td><td>string:String</td><td>typHints:Option[Seq[core.datastructures.graph.node.ResourceNode]]</td></tr>
<tr><td>core.nlp.SubjAround</td><td>surrounding11</td><td>core.nlp.SubjAround.surrounding11: core.datastructures.graph.traversal.NodeList</td><td>core.datastructures.graph.traversal.NodeList</td><td>SubjAround:core.nlp.SubjAround</td><td></td><td></td></tr>
<tr><td>core.nlp.SubjAround</td><td>surrounding1</td><td>core.nlp.SubjAround.surrounding1: core.datastructures.graph.traversal.NodeList</td><td>core.datastructures.graph.traversal.NodeList</td><td>SubjAround:core.nlp.SubjAround</td><td></td><td></td></tr>
<tr><td>core.nlp.Text</td><td>copy</td><td>core.nlp.Text.copy(string: String): core.nlp.Text</td><td>core.nlp.Text</td><td>Text:core.nlp.Text</td><td>string:String</td><td></td></tr>
<tr><td>core.nlp.TextPredicates</td><td>connectingPredicates</td><td>core.nlp.TextPredicates.connectingPredicates(other: core.nlp.TextPredicates): List[String]</td><td>List[String]</td><td>TextPredicates:core.nlp.TextPredicates</td><td>other:core.nlp.TextPredicates</td><td></td></tr>
<tr><td>core.nlp.TextPredicates</td><td>dateProperty</td><td>core.nlp.TextPredicates.dateProperty(predicate: String): Seq[java.util.Date]</td><td>Seq[java.util.Date]</td><td>TextPredicates:core.nlp.TextPredicates</td><td>predicate:String</td><td></td></tr>
<tr><td>core.nlp.TextPredicates</td><td>intersectionSize</td><td>core.nlp.TextPredicates.intersectionSize(other: core.nlp.TextPredicates): Int</td><td>Int</td><td>TextPredicates:core.nlp.TextPredicates</td><td>other:core.nlp.TextPredicates</td><td></td></tr>
<tr><td>core.nlp.TextPredicates</td><td>numericProperty</td><td>core.nlp.TextPredicates.numericProperty(predicate: String): Seq[Double]</td><td>Seq[Double]</td><td>TextPredicates:core.nlp.TextPredicates</td><td>predicate:String</td><td></td></tr>
<tr><td>core.nlp.TextPredicates</td><td>targets</td><td>core.nlp.TextPredicates.targets: IndexedSeq[Int]</td><td>IndexedSeq[Int]</td><td>TextPredicates:core.nlp.TextPredicates</td><td></td><td></td></tr>
<tr><td>core.nlp.TextPredicates</td><td>withProperty</td><td>core.nlp.TextPredicates.withProperty(predicate: String): core.datastructures.graph.traversal.NodeList</td><td>core.datastructures.graph.traversal.NodeList</td><td>TextPredicates:core.nlp.TextPredicates</td><td>predicate:String</td><td></td></tr>
<tr><td>core.providers.publicData.Census</td><td>attributesOfZipCode</td><td>core.providers.publicData.Census.attributesOfZipCode(zip: core.datastructures.Zipcode): Map[String,Double]</td><td>Map[String,Double]</td><td>zip:core.datastructures.Zipcode</td><td></td><td></td></tr>
<tr><td>core.providers.publicData.WorldBank</td><td>worldDevelopmentIndicators</td><td>core.providers.publicData.WorldBank.worldDevelopmentIndicators(country: core.nlp.Country): Map[String,core.common.datastructures.TimeSeries[Double]]</td><td>Map[String,core.common.datastructures.TimeSeries[Double]]</td><td>country:core.nlp.Country</td><td></td><td></td></tr>
<tr><td>java.lang.CharSequence</td><td>length</td><td>java.lang.CharSequence.length(): Int</td><td>Int</td><td>CharSequence:java.lang.CharSequence</td><td></td><td></td></tr>
<tr><td>java.lang.CharSequence</td><td>subSequence</td><td>java.lang.CharSequence.subSequence(x$1: Int,x$2: Int): java.lang.CharSequence</td><td>java.lang.CharSequence</td><td>CharSequence:java.lang.CharSequence</td><td>x$1:Int</td><td>x$2:Int</td></tr>
<tr><td>java.lang.Double</td><td>isInfinite</td><td>java.lang.Double.isInfinite(): Boolean</td><td>Boolean</td><td>Double:java.lang.Double</td><td></td><td></td></tr>
<tr><td>java.lang.Double</td><td>isNaN</td><td>java.lang.Double.isNaN(): Boolean</td><td>Boolean</td><td>Double:java.lang.Double</td><td></td><td></td></tr>
<tr><td>java.lang.Enum</td><td>name</td><td>java.lang.Enum.name(): java.lang.String</td><td>String</td><td>Enum:java.lang.Enum[E]</td><td></td><td></td></tr>
<tr><td>java.lang.Enum</td><td>ordinal</td><td>java.lang.Enum.ordinal(): Int</td><td>Int</td><td>Enum:java.lang.Enum[E]</td><td></td><td></td></tr>
<tr><td>java.lang.String</td><td>$plus</td><td>java.lang.String.$plus(x$1: Any): java.lang.String</td><td>String</td><td>String:java.lang.String</td><td>x$1:Any</td><td></td></tr>
<tr><td>java.lang.String</td><td>codePointCount</td><td>java.lang.String.codePointCount(x$1: Int,x$2: Int): Int</td><td>Int</td><td>String:java.lang.String</td><td>x$1:Int</td><td>x$2:Int</td></tr>
<tr><td>java.lang.String</td><td>compareToIgnoreCase</td><td>java.lang.String.compareToIgnoreCase(x$1: java.lang.String): Int</td><td>Int</td><td>String:java.lang.String</td><td>x$1:java.lang.String</td><td></td></tr>
<tr><td>java.lang.String</td><td>contains</td><td>java.lang.String.contains(x$1: java.lang.CharSequence): Boolean</td><td>Boolean</td><td>String:java.lang.String</td><td>x$1:java.lang.CharSequence</td><td></td></tr>
<tr><td>java.lang.String</td><td>contentEquals</td><td>java.lang.String.contentEquals(x$1: java.lang.CharSequence): Boolean</td><td>Boolean</td><td>String:java.lang.String</td><td>x$1:java.lang.CharSequence</td><td></td></tr>
<tr><td>java.lang.String</td><td>endsWith</td><td>java.lang.String.endsWith(x$1: java.lang.String): Boolean</td><td>Boolean</td><td>String:java.lang.String</td><td>x$1:java.lang.String</td><td></td></tr>
<tr><td>java.lang.String</td><td>equalsIgnoreCase</td><td>java.lang.String.equalsIgnoreCase(x$1: java.lang.String): Boolean</td><td>Boolean</td><td>String:java.lang.String</td><td>x$1:java.lang.String</td><td></td></tr>
<tr><td>java.lang.String</td><td>indexOf</td><td>java.lang.String.indexOf(x$1: Int): Int</td><td>Int</td><td>String:java.lang.String</td><td>x$1:Int</td><td></td></tr>
<tr><td>java.lang.String</td><td>indexOf</td><td>java.lang.String.indexOf(x$1: Int,x$2: Int): Int</td><td>Int</td><td>String:java.lang.String</td><td>x$1:Int</td><td>x$2:Int</td></tr>
<tr><td>java.lang.String</td><td>indexOf</td><td>java.lang.String.indexOf(x$1: java.lang.String): Int</td><td>Int</td><td>String:java.lang.String</td><td>x$1:java.lang.String</td><td></td></tr>
<tr><td>java.lang.String</td><td>indexOf</td><td>java.lang.String.indexOf(x$1: java.lang.String,x$2: Int): Int</td><td>Int</td><td>String:java.lang.String</td><td>x$1:java.lang.String</td><td>x$2:Int</td></tr>
<tr><td>java.lang.String</td><td>isEmpty</td><td>java.lang.String.isEmpty(): Boolean</td><td>Boolean</td><td>String:java.lang.String</td><td></td><td></td></tr>
<tr><td>java.lang.String</td><td>replace</td><td>java.lang.String.replace(x$1: Char,x$2: Char): java.lang.String</td><td>String</td><td>String:java.lang.String</td><td>x$1:Char</td><td>x$2:Char</td></tr>
<tr><td>java.lang.String</td><td>replace</td><td>java.lang.String.replace(x$1: java.lang.CharSequence,x$2: java.lang.CharSequence): java.lang.String</td><td>String</td><td>String:java.lang.String</td><td>x$1:java.lang.CharSequence</td><td>x$2:java.lang.CharSequence</td></tr>
<tr><td>java.lang.String</td><td>replaceAll</td><td>java.lang.String.replaceAll(x$1: java.lang.String,x$2: java.lang.String): java.lang.String</td><td>String</td><td>String:java.lang.String</td><td>x$1:java.lang.String</td><td>x$2:java.lang.String</td></tr>
<tr><td>java.lang.String</td><td>replaceFirst</td><td>java.lang.String.replaceFirst(x$1: java.lang.String,x$2: java.lang.String): java.lang.String</td><td>String</td><td>String:java.lang.String</td><td>x$1:java.lang.String</td><td>x$2:java.lang.String</td></tr>
<tr><td>java.lang.String</td><td>split</td><td>java.lang.String.split(x$1: java.lang.String): Array[java.lang.String]</td><td>Array[java.lang.String]</td><td>String:java.lang.String</td><td>x$1:java.lang.String</td><td></td></tr>
<tr><td>java.lang.String</td><td>split</td><td>java.lang.String.split(x$1: java.lang.String,x$2: Int): Array[java.lang.String]</td><td>Array[java.lang.String]</td><td>String:java.lang.String</td><td>x$1:java.lang.String</td><td>x$2:Int</td></tr>
<tr><td>java.lang.String</td><td>startsWith</td><td>java.lang.String.startsWith(x$1: java.lang.String): Boolean</td><td>Boolean</td><td>String:java.lang.String</td><td>x$1:java.lang.String</td><td></td></tr>
<tr><td>java.lang.String</td><td>startsWith</td><td>java.lang.String.startsWith(x$1: java.lang.String,x$2: Int): Boolean</td><td>Boolean</td><td>String:java.lang.String</td><td>x$1:java.lang.String</td><td>x$2:Int</td></tr>
<tr><td>java.lang.String</td><td>substring</td><td>java.lang.String.substring(x$1: Int): java.lang.String</td><td>String</td><td>String:java.lang.String</td><td>x$1:Int</td><td></td></tr>
<tr><td>java.lang.String</td><td>substring</td><td>java.lang.String.substring(x$1: Int,x$2: Int): java.lang.String</td><td>String</td><td>String:java.lang.String</td><td>x$1:Int</td><td>x$2:Int</td></tr>
<tr><td>java.lang.String</td><td>toLowerCase</td><td>java.lang.String.toLowerCase(): java.lang.String</td><td>String</td><td>String:java.lang.String</td><td></td><td></td></tr>
<tr><td>java.lang.String</td><td>toUpperCase</td><td>java.lang.String.toUpperCase(): java.lang.String</td><td>String</td><td>String:java.lang.String</td><td></td><td></td></tr>
<tr><td>java.lang.String</td><td>trim</td><td>java.lang.String.trim(): java.lang.String</td><td>String</td><td>String:java.lang.String</td><td></td><td></td></tr>
<tr><td>java.text.DateFormat</td><td>format</td><td>java.text.DateFormat.format(x$1: java.util.Date): java.lang.String</td><td>String</td><td>DateFormat:java.text.DateFormat</td><td>x$1:java.util.Date</td><td></td></tr>
<tr><td>java.text.DateFormat</td><td>getCalendar</td><td>java.text.DateFormat.getCalendar(): java.util.Calendar</td><td>java.util.Calendar</td><td>DateFormat:java.text.DateFormat</td><td></td><td></td></tr>
<tr><td>java.text.DateFormat</td><td>getNumberFormat</td><td>java.text.DateFormat.getNumberFormat(): java.text.NumberFormat</td><td>java.text.NumberFormat</td><td>DateFormat:java.text.DateFormat</td><td></td><td></td></tr>
<tr><td>java.text.DateFormat</td><td>getTimeZone</td><td>java.text.DateFormat.getTimeZone(): java.util.TimeZone</td><td>java.util.TimeZone</td><td>DateFormat:java.text.DateFormat</td><td></td><td></td></tr>
<tr><td>java.text.DateFormat</td><td>isLenient</td><td>java.text.DateFormat.isLenient(): Boolean</td><td>Boolean</td><td>DateFormat:java.text.DateFormat</td><td></td><td></td></tr>
<tr><td>java.text.DateFormat</td><td>parse</td><td>java.text.DateFormat.parse(x$1: java.lang.String): java.util.Date</td><td>java.util.Date</td><td>DateFormat:java.text.DateFormat</td><td>x$1:java.lang.String</td><td></td></tr>
<tr><td>java.text.Format</td><td>format</td><td>java.text.Format.format(x$1: Any): java.lang.String</td><td>String</td><td>Format:java.text.Format</td><td>x$1:Any</td><td></td></tr>
<tr><td>java.text.NumberFormat</td><td>format</td><td>java.text.NumberFormat.format(x$1: Double): java.lang.String</td><td>String</td><td>NumberFormat:java.text.NumberFormat</td><td>x$1:Double</td><td></td></tr>
<tr><td>java.text.NumberFormat</td><td>format</td><td>java.text.NumberFormat.format(x$1: Long): java.lang.String</td><td>String</td><td>NumberFormat:java.text.NumberFormat</td><td>x$1:Long</td><td></td></tr>
<tr><td>java.text.NumberFormat</td><td>getCurrency</td><td>java.text.NumberFormat.getCurrency(): java.util.Currency</td><td>java.util.Currency</td><td>NumberFormat:java.text.NumberFormat</td><td></td><td></td></tr>
<tr><td>java.text.NumberFormat</td><td>getMaximumFractionDigits</td><td>java.text.NumberFormat.getMaximumFractionDigits(): Int</td><td>Int</td><td>NumberFormat:java.text.NumberFormat</td><td></td><td></td></tr>
<tr><td>java.text.NumberFormat</td><td>getMaximumIntegerDigits</td><td>java.text.NumberFormat.getMaximumIntegerDigits(): Int</td><td>Int</td><td>NumberFormat:java.text.NumberFormat</td><td></td><td></td></tr>
<tr><td>java.text.NumberFormat</td><td>getMinimumFractionDigits</td><td>java.text.NumberFormat.getMinimumFractionDigits(): Int</td><td>Int</td><td>NumberFormat:java.text.NumberFormat</td><td></td><td></td></tr>
<tr><td>java.text.NumberFormat</td><td>getMinimumIntegerDigits</td><td>java.text.NumberFormat.getMinimumIntegerDigits(): Int</td><td>Int</td><td>NumberFormat:java.text.NumberFormat</td><td></td><td></td></tr>
<tr><td>java.text.NumberFormat</td><td>isGroupingUsed</td><td>java.text.NumberFormat.isGroupingUsed(): Boolean</td><td>Boolean</td><td>NumberFormat:java.text.NumberFormat</td><td></td><td></td></tr>
<tr><td>java.text.NumberFormat</td><td>isParseIntegerOnly</td><td>java.text.NumberFormat.isParseIntegerOnly(): Boolean</td><td>Boolean</td><td>NumberFormat:java.text.NumberFormat</td><td></td><td></td></tr>
<tr><td>java.text.SimpleDateFormat</td><td>get2DigitYearStart</td><td>java.text.SimpleDateFormat.get2DigitYearStart(): java.util.Date</td><td>java.util.Date</td><td>SimpleDateFormat:java.text.SimpleDateFormat</td><td></td><td></td></tr>
<tr><td>java.text.SimpleDateFormat</td><td>toLocalizedPattern</td><td>java.text.SimpleDateFormat.toLocalizedPattern(): java.lang.String</td><td>String</td><td>SimpleDateFormat:java.text.SimpleDateFormat</td><td></td><td></td></tr>
<tr><td>java.text.SimpleDateFormat</td><td>toPattern</td><td>java.text.SimpleDateFormat.toPattern(): java.lang.String</td><td>String</td><td>SimpleDateFormat:java.text.SimpleDateFormat</td><td></td><td></td></tr>
<tr><td>java.util.Calendar</td><td>after</td><td>java.util.Calendar.after(x$1: Any): Boolean</td><td>Boolean</td><td>Calendar:java.util.Calendar</td><td>x$1:Any</td><td></td></tr>
<tr><td>java.util.Calendar</td><td>before</td><td>java.util.Calendar.before(x$1: Any): Boolean</td><td>Boolean</td><td>Calendar:java.util.Calendar</td><td>x$1:Any</td><td></td></tr>
<tr><td>java.util.Calendar</td><td>get</td><td>java.util.Calendar.get(x$1: Int): Int</td><td>Int</td><td>Calendar:java.util.Calendar</td><td>x$1:Int</td><td></td></tr>
<tr><td>java.util.Calendar</td><td>getActualMaximum</td><td>java.util.Calendar.getActualMaximum(x$1: Int): Int</td><td>Int</td><td>Calendar:java.util.Calendar</td><td>x$1:Int</td><td></td></tr>
<tr><td>java.util.Calendar</td><td>getActualMinimum</td><td>java.util.Calendar.getActualMinimum(x$1: Int): Int</td><td>Int</td><td>Calendar:java.util.Calendar</td><td>x$1:Int</td><td></td></tr>
<tr><td>java.util.Calendar</td><td>getFirstDayOfWeek</td><td>java.util.Calendar.getFirstDayOfWeek(): Int</td><td>Int</td><td>Calendar:java.util.Calendar</td><td></td><td></td></tr>
<tr><td>java.util.Calendar</td><td>getGreatestMinimum</td><td>java.util.Calendar.getGreatestMinimum(x$1: Int): Int</td><td>Int</td><td>Calendar:java.util.Calendar</td><td>x$1:Int</td><td></td></tr>
<tr><td>java.util.Calendar</td><td>getLeastMaximum</td><td>java.util.Calendar.getLeastMaximum(x$1: Int): Int</td><td>Int</td><td>Calendar:java.util.Calendar</td><td>x$1:Int</td><td></td></tr>
<tr><td>java.util.Calendar</td><td>getMaximum</td><td>java.util.Calendar.getMaximum(x$1: Int): Int</td><td>Int</td><td>Calendar:java.util.Calendar</td><td>x$1:Int</td><td></td></tr>
<tr><td>java.util.Calendar</td><td>getMinimalDaysInFirstWeek</td><td>java.util.Calendar.getMinimalDaysInFirstWeek(): Int</td><td>Int</td><td>Calendar:java.util.Calendar</td><td></td><td></td></tr>
<tr><td>java.util.Calendar</td><td>getMinimum</td><td>java.util.Calendar.getMinimum(x$1: Int): Int</td><td>Int</td><td>Calendar:java.util.Calendar</td><td>x$1:Int</td><td></td></tr>
<tr><td>java.util.Calendar</td><td>getTime</td><td>java.util.Calendar.getTime(): java.util.Date</td><td>java.util.Date</td><td>Calendar:java.util.Calendar</td><td></td><td></td></tr>
<tr><td>java.util.Calendar</td><td>getTimeInMillis</td><td>java.util.Calendar.getTimeInMillis(): Long</td><td>Long</td><td>Calendar:java.util.Calendar</td><td></td><td></td></tr>
<tr><td>java.util.Calendar</td><td>getTimeZone</td><td>java.util.Calendar.getTimeZone(): java.util.TimeZone</td><td>java.util.TimeZone</td><td>Calendar:java.util.Calendar</td><td></td><td></td></tr>
<tr><td>java.util.Calendar</td><td>getWeekYear</td><td>java.util.Calendar.getWeekYear(): Int</td><td>Int</td><td>Calendar:java.util.Calendar</td><td></td><td></td></tr>
<tr><td>java.util.Calendar</td><td>getWeeksInWeekYear</td><td>java.util.Calendar.getWeeksInWeekYear(): Int</td><td>Int</td><td>Calendar:java.util.Calendar</td><td></td><td></td></tr>
<tr><td>java.util.Calendar</td><td>isLenient</td><td>java.util.Calendar.isLenient(): Boolean</td><td>Boolean</td><td>Calendar:java.util.Calendar</td><td></td><td></td></tr>
<tr><td>java.util.Calendar</td><td>isSet</td><td>java.util.Calendar.isSet(x$1: Int): Boolean</td><td>Boolean</td><td>Calendar:java.util.Calendar</td><td>x$1:Int</td><td></td></tr>
<tr><td>java.util.Calendar</td><td>isWeekDateSupported</td><td>java.util.Calendar.isWeekDateSupported(): Boolean</td><td>Boolean</td><td>Calendar:java.util.Calendar</td><td></td><td></td></tr>
<tr><td>java.util.Currency</td><td>getCurrencyCode</td><td>java.util.Currency.getCurrencyCode(): java.lang.String</td><td>String</td><td>Currency:java.util.Currency</td><td></td><td></td></tr>
<tr><td>java.util.Currency</td><td>getDefaultFractionDigits</td><td>java.util.Currency.getDefaultFractionDigits(): Int</td><td>Int</td><td>Currency:java.util.Currency</td><td></td><td></td></tr>
<tr><td>java.util.Currency</td><td>getDisplayName</td><td>java.util.Currency.getDisplayName(): java.lang.String</td><td>String</td><td>Currency:java.util.Currency</td><td></td><td></td></tr>
<tr><td>java.util.Currency</td><td>getNumericCode</td><td>java.util.Currency.getNumericCode(): Int</td><td>Int</td><td>Currency:java.util.Currency</td><td></td><td></td></tr>
<tr><td>java.util.Currency</td><td>getSymbol</td><td>java.util.Currency.getSymbol(): java.lang.String</td><td>String</td><td>Currency:java.util.Currency</td><td></td><td></td></tr>
<tr><td>java.util.Date</td><td>after</td><td>java.util.Date.after(x$1: java.util.Date): Boolean</td><td>Boolean</td><td>Date:java.util.Date</td><td>x$1:java.util.Date</td><td></td></tr>
<tr><td>java.util.Date</td><td>before</td><td>java.util.Date.before(x$1: java.util.Date): Boolean</td><td>Boolean</td><td>Date:java.util.Date</td><td>x$1:java.util.Date</td><td></td></tr>
<tr><td>java.util.Date</td><td>getMinutes</td><td>java.util.Date.getMinutes(): Int</td><td>Int</td><td>Date:java.util.Date</td><td></td><td></td></tr>
<tr><td>java.util.Date</td><td>getMonth</td><td>java.util.Date.getMonth(): Int</td><td>Int</td><td>Date:java.util.Date</td><td></td><td></td></tr>
<tr><td>java.util.Date</td><td>getSeconds</td><td>java.util.Date.getSeconds(): Int</td><td>Int</td><td>Date:java.util.Date</td><td></td><td></td></tr>
<tr><td>java.util.Date</td><td>getTime</td><td>java.util.Date.getTime(): Long</td><td>Long</td><td>Date:java.util.Date</td><td></td><td></td></tr>
<tr><td>java.util.Date</td><td>getTimezoneOffset</td><td>java.util.Date.getTimezoneOffset(): Int</td><td>Int</td><td>Date:java.util.Date</td><td></td><td></td></tr>
<tr><td>java.util.Date</td><td>getYear</td><td>java.util.Date.getYear(): Int</td><td>Int</td><td>Date:java.util.Date</td><td></td><td></td></tr>
<tr><td>java.util.Date</td><td>toGMTString</td><td>java.util.Date.toGMTString(): java.lang.String</td><td>String</td><td>Date:java.util.Date</td><td></td><td></td></tr>
<tr><td>java.util.Date</td><td>toLocaleString</td><td>java.util.Date.toLocaleString(): java.lang.String</td><td>String</td><td>Date:java.util.Date</td><td></td><td></td></tr>
<tr><td>java.util.TimeZone</td><td>getDSTSavings</td><td>java.util.TimeZone.getDSTSavings(): Int</td><td>Int</td><td>TimeZone:java.util.TimeZone</td><td></td><td></td></tr>
<tr><td>java.util.TimeZone</td><td>getDisplayName</td><td>java.util.TimeZone.getDisplayName(): java.lang.String</td><td>String</td><td>TimeZone:java.util.TimeZone</td><td></td><td></td></tr>
<tr><td>java.util.TimeZone</td><td>getDisplayName</td><td>java.util.TimeZone.getDisplayName(x$1: Boolean,x$2: Int): java.lang.String</td><td>String</td><td>TimeZone:java.util.TimeZone</td><td>x$1:Boolean</td><td>x$2:Int</td></tr>
<tr><td>java.util.TimeZone</td><td>getID</td><td>java.util.TimeZone.getID(): java.lang.String</td><td>String</td><td>TimeZone:java.util.TimeZone</td><td></td><td></td></tr>
<tr><td>java.util.TimeZone</td><td>getOffset</td><td>java.util.TimeZone.getOffset(x$1: Long): Int</td><td>Int</td><td>TimeZone:java.util.TimeZone</td><td>x$1:Long</td><td></td></tr>
<tr><td>java.util.TimeZone</td><td>getRawOffset</td><td>java.util.TimeZone.getRawOffset(): Int</td><td>Int</td><td>TimeZone:java.util.TimeZone</td><td></td><td></td></tr>
<tr><td>java.util.TimeZone</td><td>hasSameRules</td><td>java.util.TimeZone.hasSameRules(x$1: java.util.TimeZone): Boolean</td><td>Boolean</td><td>TimeZone:java.util.TimeZone</td><td>x$1:java.util.TimeZone</td><td></td></tr>
<tr><td>java.util.TimeZone</td><td>inDaylightTime</td><td>java.util.TimeZone.inDaylightTime(x$1: java.util.Date): Boolean</td><td>Boolean</td><td>TimeZone:java.util.TimeZone</td><td>x$1:java.util.Date</td><td></td></tr>
<tr><td>java.util.TimeZone</td><td>observesDaylightTime</td><td>java.util.TimeZone.observesDaylightTime(): Boolean</td><td>Boolean</td><td>TimeZone:java.util.TimeZone</td><td></td><td></td></tr>
<tr><td>java.util.TimeZone</td><td>useDaylightTime</td><td>java.util.TimeZone.useDaylightTime(): Boolean</td><td>Boolean</td><td>TimeZone:java.util.TimeZone</td><td></td><td></td></tr>
<tr><td>math</td><td>normalizer</td><td>core.Solving.SpecialFunctions.normalizer(x: Double,deciles: IndexedSeq[Double]): Double</td><td>Double</td><td>x:Double</td><td>deciles:IndexedSeq[Double]</td><td></td></tr>
<tr><td>math</td><td>sigmoid</td><td>core.Solving.SpecialFunctions.sigmoid(num: Double): Double</td><td>Double</td><td>num:Double</td><td></td><td></td></tr>
<tr><td>math</td><td>abstractions</td><td>core.Solving.provider.CustomGraphFuzzy.abstractions(text: core.nlp.SemanticWrapper): core.datastructures.Histogram[(String,String)]</td><td>core.datastructures.Histogram[(String, String)]</td><td>text:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>math</td><td>getRoundingMode</td><td>java.text.NumberFormat.getRoundingMode(): java.math.RoundingMode</td><td>java.math.RoundingMode</td><td>NumberFormat:java.text.NumberFormat</td><td></td><td></td></tr>
<tr><td>math</td><td>$percent</td><td>scala.Double.$percent(x: Byte): Double</td><td>Double</td><td>Double:Double</td><td>x:Byte</td><td></td></tr>
<tr><td>math</td><td>$percent</td><td>scala.Double.$percent(x: Char): Double</td><td>Double</td><td>Double:Double</td><td>x:Char</td><td></td></tr>
<tr><td>math</td><td>$percent</td><td>scala.Double.$percent(x: Double): Double</td><td>Double</td><td>Double:Double</td><td>x:Double</td><td></td></tr>
<tr><td>math</td><td>$percent</td><td>scala.Double.$percent(x: Int): Double</td><td>Double</td><td>Double:Double</td><td>x:Int</td><td></td></tr>
<tr><td>math</td><td>$percent</td><td>scala.Double.$percent(x: Long): Double</td><td>Double</td><td>Double:Double</td><td>x:Long</td><td></td></tr>
<tr><td>math</td><td>toChar</td><td>scala.Double.toChar: Char</td><td>Char</td><td>Double:Double</td><td></td><td></td></tr>
<tr><td>math</td><td>toInt</td><td>scala.Double.toInt: Int</td><td>Int</td><td>Double:Double</td><td></td><td></td></tr>
<tr><td>math</td><td>toLong</td><td>scala.Double.toLong: Long</td><td>Long</td><td>Double:Double</td><td></td><td></td></tr>
<tr><td>math</td><td>unary_$minus</td><td>scala.Double.unary_$minus: Double</td><td>Double</td><td>Double:Double</td><td></td><td></td></tr>
<tr><td>math</td><td>$div</td><td>scala.Int.$div(x: Byte): Int</td><td>Int</td><td>Int:Int</td><td>x:Byte</td><td></td></tr>
<tr><td>math</td><td>$div</td><td>scala.Int.$div(x: Char): Int</td><td>Int</td><td>Int:Int</td><td>x:Char</td><td></td></tr>
<tr><td>math</td><td>$div</td><td>scala.Int.$div(x: Double): Double</td><td>Double</td><td>Int:Int</td><td>x:Double</td><td></td></tr>
<tr><td>math</td><td>$div</td><td>scala.Int.$div(x: Int): Int</td><td>Int</td><td>Int:Int</td><td>x:Int</td><td></td></tr>
<tr><td>math</td><td>$div</td><td>scala.Int.$div(x: Long): Long</td><td>Long</td><td>Int:Int</td><td>x:Long</td><td></td></tr>
<tr><td>math</td><td>$percent</td><td>scala.Int.$percent(x: Byte): Int</td><td>Int</td><td>Int:Int</td><td>x:Byte</td><td></td></tr>
<tr><td>math</td><td>$percent</td><td>scala.Int.$percent(x: Char): Int</td><td>Int</td><td>Int:Int</td><td>x:Char</td><td></td></tr>
<tr><td>math</td><td>$percent</td><td>scala.Int.$percent(x: Double): Double</td><td>Double</td><td>Int:Int</td><td>x:Double</td><td></td></tr>
<tr><td>math</td><td>$percent</td><td>scala.Int.$percent(x: Int): Int</td><td>Int</td><td>Int:Int</td><td>x:Int</td><td></td></tr>
<tr><td>math</td><td>$percent</td><td>scala.Int.$percent(x: Long): Long</td><td>Long</td><td>Int:Int</td><td>x:Long</td><td></td></tr>
<tr><td>math</td><td>toChar</td><td>scala.Int.toChar: Char</td><td>Char</td><td>Int:Int</td><td></td><td></td></tr>
<tr><td>math</td><td>toDouble</td><td>scala.Int.toDouble: Double</td><td>Double</td><td>Int:Int</td><td></td><td></td></tr>
<tr><td>math</td><td>toLong</td><td>scala.Int.toLong: Long</td><td>Long</td><td>Int:Int</td><td></td><td></td></tr>
<tr><td>math</td><td>unary_$minus</td><td>scala.Int.unary_$minus: Int</td><td>Int</td><td>Int:Int</td><td></td><td></td></tr>
<tr><td>math</td><td>unary_$tilde</td><td>scala.Int.unary_$tilde: Int</td><td>Int</td><td>Int:Int</td><td></td><td></td></tr>
<tr><td>math</td><td>IEEEremainder</td><td>scala.math.IEEEremainder(x: Double,y: Double): Double</td><td>Double</td><td>x:Double</td><td>y:Double</td><td></td></tr>
<tr><td>math</td><td>abs</td><td>scala.math.abs(x: Double): Double</td><td>Double</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>math</td><td>abs</td><td>scala.math.abs(x: Int): Int</td><td>Int</td><td>x:Int</td><td></td><td></td></tr>
<tr><td>math</td><td>abs</td><td>scala.math.abs(x: Long): Long</td><td>Long</td><td>x:Long</td><td></td><td></td></tr>
<tr><td>math</td><td>cbrt</td><td>scala.math.cbrt(x: Double): Double</td><td>Double</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>math</td><td>ceil</td><td>scala.math.ceil(x: Double): Double</td><td>Double</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>math</td><td>exp</td><td>scala.math.exp(x: Double): Double</td><td>Double</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>math</td><td>expm1</td><td>scala.math.expm1(x: Double): Double</td><td>Double</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>math</td><td>floor</td><td>scala.math.floor(x: Double): Double</td><td>Double</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>math</td><td>hypot</td><td>scala.math.hypot(x: Double,y: Double): Double</td><td>Double</td><td>x:Double</td><td>y:Double</td><td></td></tr>
<tr><td>math</td><td>log</td><td>scala.math.log(x: Double): Double</td><td>Double</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>math</td><td>log10</td><td>scala.math.log10(x: Double): Double</td><td>Double</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>math</td><td>log1p</td><td>scala.math.log1p(x: Double): Double</td><td>Double</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>math</td><td>max</td><td>scala.math.max(x: Double,y: Double): Double</td><td>Double</td><td>x:Double</td><td>y:Double</td><td></td></tr>
<tr><td>math</td><td>max</td><td>scala.math.max(x: Int,y: Int): Int</td><td>Int</td><td>x:Int</td><td>y:Int</td><td></td></tr>
<tr><td>math</td><td>max</td><td>scala.math.max(x: Long,y: Long): Long</td><td>Long</td><td>x:Long</td><td>y:Long</td><td></td></tr>
<tr><td>math</td><td>min</td><td>scala.math.min(x: Double,y: Double): Double</td><td>Double</td><td>x:Double</td><td>y:Double</td><td></td></tr>
<tr><td>math</td><td>min</td><td>scala.math.min(x: Int,y: Int): Int</td><td>Int</td><td>x:Int</td><td>y:Int</td><td></td></tr>
<tr><td>math</td><td>min</td><td>scala.math.min(x: Long,y: Long): Long</td><td>Long</td><td>x:Long</td><td>y:Long</td><td></td></tr>
<tr><td>math</td><td>pow</td><td>scala.math.pow(x: Double,y: Double): Double</td><td>Double</td><td>x:Double</td><td>y:Double</td><td></td></tr>
<tr><td>math</td><td>round</td><td>scala.math.round(x: Double): Long</td><td>Long</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>math</td><td>round</td><td>scala.math.round(x: Long): Long</td><td>Long</td><td>x:Long</td><td></td><td></td></tr>
<tr><td>math</td><td>signum</td><td>scala.math.signum(x: Double): Double</td><td>Double</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>math</td><td>signum</td><td>scala.math.signum(x: Int): Int</td><td>Int</td><td>x:Int</td><td></td><td></td></tr>
<tr><td>math</td><td>signum</td><td>scala.math.signum(x: Long): Long</td><td>Long</td><td>x:Long</td><td></td><td></td></tr>
<tr><td>math</td><td>sqrt</td><td>scala.math.sqrt(x: Double): Double</td><td>Double</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>math</td><td>toDegrees</td><td>scala.math.toDegrees(x: Double): Double</td><td>Double</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>math</td><td>abs</td><td>scala.runtime.RichChar.abs: Char</td><td>Char</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>math, trigonometry</td><td>acos</td><td>scala.math.acos(x: Double): Double</td><td>Double</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>math, trigonometry</td><td>asin</td><td>scala.math.asin(x: Double): Double</td><td>Double</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>math, trigonometry</td><td>atan</td><td>scala.math.atan(x: Double): Double</td><td>Double</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>math, trigonometry</td><td>atan2</td><td>scala.math.atan2(y: Double,x: Double): Double</td><td>Double</td><td>y:Double</td><td>x:Double</td><td></td></tr>
<tr><td>math, trigonometry</td><td>cos</td><td>scala.math.cos(x: Double): Double</td><td>Double</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>math, trigonometry</td><td>cosh</td><td>scala.math.cosh(x: Double): Double</td><td>Double</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>math, trigonometry</td><td>sin</td><td>scala.math.sin(x: Double): Double</td><td>Double</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>math, trigonometry</td><td>sinh</td><td>scala.math.sinh(x: Double): Double</td><td>Double</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>math, trigonometry</td><td>tan</td><td>scala.math.tan(x: Double): Double</td><td>Double</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>math, trigonometry</td><td>tanh</td><td>scala.math.tanh(x: Double): Double</td><td>Double</td><td>x:Double</td><td></td><td></td></tr>
<tr><td>new core.datastructures</td><td>new LatLong</td><td>new core.datastructures.LatLong(latitude: Double, longitude: Double)core.datastructures.LatLong</td><td>core.datastructures.LatLong</td><td>latitude:Double</td><td>longitude:Double</td><td></td></tr>
<tr><td>new core.nlp</td><td>new LatLongConcept</td><td>new core.nlp.LatLongConcept(string: String, typHints: Option[Seq[core.datastructures.graph.node.ResourceNode]])core.nlp.LatLongConcept</td><td>core.nlp.LatLongConcept</td><td>string:String</td><td>typHints:Option[Seq[core.datastructures.graph.node.ResourceNode]]</td><td></td></tr>
<tr><td>new core.nlp</td><td>new Text</td><td>new core.nlp.Text(string: String)core.nlp.Text</td><td>core.nlp.Text</td><td>string:String</td><td></td><td></td></tr>
<tr><td>new java.lang</td><td>new Boolean</td><td>new java.lang.Boolean(x$1: java.lang.String)java.lang.Boolean</td><td>scala.Boolean</td><td>x$1:java.lang.String</td><td></td><td></td></tr>
<tr><td>new java.lang</td><td>new Byte</td><td>new java.lang.Byte(x$1: Byte)java.lang.Byte</td><td>java.lang.Byte</td><td>x$1:Byte</td><td></td><td></td></tr>
<tr><td>new java.lang</td><td>new Byte</td><td>new java.lang.Byte(x$1: java.lang.String)java.lang.Byte</td><td>java.lang.Byte</td><td>x$1:java.lang.String</td><td></td><td></td></tr>
<tr><td>new java.lang</td><td>new Character</td><td>new java.lang.Character(x$1: Char)java.lang.Character</td><td>scala.Char</td><td>x$1:Char</td><td></td><td></td></tr>
<tr><td>new scala</td><td>new Tuple2</td><td>new scala.Tuple2(_1: T1, _2: T2)(T1, T2)</td><td>(T1, T2)</td><td>_1:T1</td><td>_2:T2</td><td></td></tr>
<tr><td>new scala.runtime</td><td>new RichChar</td><td>new scala.runtime.RichChar(self: Char)scala.runtime.RichChar</td><td>scala.runtime.RichChar</td><td>self:Char</td><td></td><td></td></tr>
<tr><td>nlp</td><td>normalizedNgrams</td><td>core.Solving.SpecialFunctions.normalizedNgrams(s: String): List[Seq[String]]</td><td>List[Seq[String]]</td><td>s:String</td><td></td><td></td></tr>
<tr><td>nlp</td><td>normalizedNgramsWithoutStopwords</td><td>core.Solving.SpecialFunctions.normalizedNgramsWithoutStopwords(s: String): List[Seq[String]]</td><td>List[Seq[String]]</td><td>s:String</td><td></td><td></td></tr>
<tr><td>nlp</td><td>tokenizeByCommonDelimiters</td><td>core.Solving.SpecialFunctions.tokenizeByCommonDelimiters(s: String): Seq[String]</td><td>Seq[String]</td><td>s:String</td><td></td><td></td></tr>
<tr><td>nlp</td><td>tokenizeByCommonDelimitersAndNormalize</td><td>core.Solving.SpecialFunctions.tokenizeByCommonDelimitersAndNormalize(s: String): Seq[String]</td><td>Seq[String]</td><td>s:String</td><td></td><td></td></tr>
<tr><td>nlp</td><td>tokenizeBySpace</td><td>core.Solving.SpecialFunctions.tokenizeBySpace(s: String): Seq[String]</td><td>Seq[String]</td><td>s:String</td><td></td><td></td></tr>
<tr><td>nlp</td><td>tokenizeCamel</td><td>core.Solving.SpecialFunctions.tokenizeCamel(x: String): Seq[String]</td><td>Seq[String]</td><td>x:String</td><td></td><td></td></tr>
<tr><td>nlp</td><td>tokenizeLastY</td><td>core.Solving.SpecialFunctions.tokenizeLastY(timeSeries: core.common.datastructures.TimeSeries[core.nlp.Text]): Seq[String]</td><td>Seq[String]</td><td>timeSeries:core.common.datastructures.TimeSeries[core.nlp.Text]</td><td></td><td></td></tr>
<tr><td>nlp</td><td>tokenizeY</td><td>core.Solving.SpecialFunctions.tokenizeY(timeSeries: core.common.datastructures.TimeSeries[core.nlp.Text]): Seq[String]</td><td>Seq[String]</td><td>timeSeries:core.common.datastructures.TimeSeries[core.nlp.Text]</td><td></td><td></td></tr>
<tr><td>nlp</td><td>adjectivesHistogram</td><td>core.Solving.TextFunctions.adjectivesHistogram(s: core.nlp.SemanticWrapper): core.datastructures.Histogram[String]</td><td>core.datastructures.Histogram[String]</td><td>s:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>nlp</td><td>countAbstractions</td><td>core.Solving.TextFunctions.countAbstractions(s: core.nlp.SemanticWrapper): Vector[(String,Double)]</td><td>Vector[(String, Double)]</td><td>s:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>nlp</td><td>fractions</td><td>core.Solving.TextFunctions.fractions(text: core.nlp.SemanticWrapper): Iterator[Double]</td><td>Iterator[Double]</td><td>text:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>nlp</td><td>ngrams</td><td>core.Solving.TextFunctions.ngrams(s: core.nlp.SemanticWrapper): List[String]</td><td>List[String]</td><td>s:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>nlp</td><td>normalizedNgrams</td><td>core.Solving.TextFunctions.normalizedNgrams(s: core.nlp.SemanticWrapper): List[Seq[String]]</td><td>List[Seq[String]]</td><td>s:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>nlp</td><td>normalizedNgramsWithoutStopwords</td><td>core.Solving.TextFunctions.normalizedNgramsWithoutStopwords(s: core.nlp.SemanticWrapper): List[Seq[String]]</td><td>List[Seq[String]]</td><td>s:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>nlp</td><td>numberIn</td><td>core.Solving.TextFunctions.numberIn(s: core.nlp.SemanticWrapper): Double</td><td>Double</td><td>s:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>nlp</td><td>numberOfWords</td><td>core.Solving.TextFunctions.numberOfWords(s: core.nlp.SemanticWrapper): Int</td><td>Int</td><td>s:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>nlp</td><td>numbers</td><td>core.Solving.TextFunctions.numbers(s: core.nlp.SemanticWrapper): Seq[Double]</td><td>Seq[Double]</td><td>s:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>nlp</td><td>sentimentDistribution</td><td>core.Solving.TextFunctions.sentimentDistribution(text: core.nlp.SemanticWrapper): core.datastructures.Histogram[Double]</td><td>core.datastructures.Histogram[Double]</td><td>text:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>nlp</td><td>stem</td><td>core.Solving.TextFunctions.stem(s: core.nlp.Token): core.nlp.Token</td><td>core.nlp.Token</td><td>s:core.nlp.Token</td><td></td><td></td></tr>
<tr><td>nlp</td><td>stemmedWordsWithoutCommonTerms</td><td>core.Solving.TextFunctions.stemmedWordsWithoutCommonTerms(text: core.nlp.SemanticWrapper): Seq[String]</td><td>Seq[String]</td><td>text:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>nlp</td><td>textSentimentScore</td><td>core.Solving.TextFunctions.textSentimentScore(text: core.nlp.SemanticWrapper): Double</td><td>Double</td><td>text:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>nlp</td><td>tokenize</td><td>core.Solving.TextFunctions.tokenize(s: core.nlp.SemanticWrapper): Seq[String]</td><td>Seq[String]</td><td>s:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>nlp</td><td>tokenizeByCommonDelimiters</td><td>core.Solving.TextFunctions.tokenizeByCommonDelimiters(s: core.nlp.SemanticWrapper): Seq[String]</td><td>Seq[String]</td><td>s:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>nlp</td><td>tokenizeByPunctuation</td><td>core.Solving.TextFunctions.tokenizeByPunctuation(s: core.nlp.SemanticWrapper): Seq[String]</td><td>Seq[String]</td><td>s:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>nlp</td><td>tokenizeByWordBoundary</td><td>core.Solving.TextFunctions.tokenizeByWordBoundary(text: core.nlp.SemanticWrapper): Vector[String]</td><td>Vector[String]</td><td>text:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>nlp</td><td>tokensWithKey</td><td>core.Solving.TextFunctions.tokensWithKey(seq: Seq[(String, core.nlp.SemanticWrapper)]): Seq[(String,String)]</td><td>Seq[(String, String)]</td><td>seq:Seq[(String, core.nlp.SemanticWrapper)]</td><td></td><td></td></tr>
<tr><td>nlp</td><td>tuplesFromTextAsTable</td><td>core.Solving.TextFunctions.tuplesFromTextAsTable(tl: core.nlp.TextList): Seq[(String,String)]</td><td>Seq[(String, String)]</td><td>tl:core.nlp.TextList</td><td></td><td></td></tr>
<tr><td>nlp</td><td>upperCaseRatio</td><td>core.Solving.TextFunctions.upperCaseRatio(s: core.nlp.SemanticWrapper): Double</td><td>Double</td><td>s:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>nlp</td><td>wordsWithoutCommonTerms</td><td>core.Solving.TextFunctions.wordsWithoutCommonTerms(text: core.nlp.SemanticWrapper): Seq[String]</td><td>Seq[String]</td><td>text:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getAttributes</td><td>edu.smu.tspell.wordnet.NounSynset.getAttributes(): Array[edu.smu.tspell.wordnet.AdjectiveSynset]</td><td>Array[edu.smu.tspell.wordnet.AdjectiveSynset]</td><td>NounSynset:edu.smu.tspell.wordnet.NounSynset</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getHypernyms</td><td>edu.smu.tspell.wordnet.NounSynset.getHypernyms(): Array[edu.smu.tspell.wordnet.NounSynset]</td><td>Array[edu.smu.tspell.wordnet.NounSynset]</td><td>NounSynset:edu.smu.tspell.wordnet.NounSynset</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getHyponyms</td><td>edu.smu.tspell.wordnet.NounSynset.getHyponyms(): Array[edu.smu.tspell.wordnet.NounSynset]</td><td>Array[edu.smu.tspell.wordnet.NounSynset]</td><td>NounSynset:edu.smu.tspell.wordnet.NounSynset</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getInstanceHypernyms</td><td>edu.smu.tspell.wordnet.NounSynset.getInstanceHypernyms(): Array[edu.smu.tspell.wordnet.NounSynset]</td><td>Array[edu.smu.tspell.wordnet.NounSynset]</td><td>NounSynset:edu.smu.tspell.wordnet.NounSynset</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getInstanceHyponyms</td><td>edu.smu.tspell.wordnet.NounSynset.getInstanceHyponyms(): Array[edu.smu.tspell.wordnet.NounSynset]</td><td>Array[edu.smu.tspell.wordnet.NounSynset]</td><td>NounSynset:edu.smu.tspell.wordnet.NounSynset</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getMemberHolonyms</td><td>edu.smu.tspell.wordnet.NounSynset.getMemberHolonyms(): Array[edu.smu.tspell.wordnet.NounSynset]</td><td>Array[edu.smu.tspell.wordnet.NounSynset]</td><td>NounSynset:edu.smu.tspell.wordnet.NounSynset</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getMemberMeronyms</td><td>edu.smu.tspell.wordnet.NounSynset.getMemberMeronyms(): Array[edu.smu.tspell.wordnet.NounSynset]</td><td>Array[edu.smu.tspell.wordnet.NounSynset]</td><td>NounSynset:edu.smu.tspell.wordnet.NounSynset</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getPartHolonyms</td><td>edu.smu.tspell.wordnet.NounSynset.getPartHolonyms(): Array[edu.smu.tspell.wordnet.NounSynset]</td><td>Array[edu.smu.tspell.wordnet.NounSynset]</td><td>NounSynset:edu.smu.tspell.wordnet.NounSynset</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getPartMeronyms</td><td>edu.smu.tspell.wordnet.NounSynset.getPartMeronyms(): Array[edu.smu.tspell.wordnet.NounSynset]</td><td>Array[edu.smu.tspell.wordnet.NounSynset]</td><td>NounSynset:edu.smu.tspell.wordnet.NounSynset</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getRegionMembers</td><td>edu.smu.tspell.wordnet.NounSynset.getRegionMembers(): Array[edu.smu.tspell.wordnet.Synset]</td><td>Array[edu.smu.tspell.wordnet.Synset]</td><td>NounSynset:edu.smu.tspell.wordnet.NounSynset</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getRegions</td><td>edu.smu.tspell.wordnet.NounSynset.getRegions(): Array[edu.smu.tspell.wordnet.NounSynset]</td><td>Array[edu.smu.tspell.wordnet.NounSynset]</td><td>NounSynset:edu.smu.tspell.wordnet.NounSynset</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getSubstanceHolonyms</td><td>edu.smu.tspell.wordnet.NounSynset.getSubstanceHolonyms(): Array[edu.smu.tspell.wordnet.NounSynset]</td><td>Array[edu.smu.tspell.wordnet.NounSynset]</td><td>NounSynset:edu.smu.tspell.wordnet.NounSynset</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getSubstanceMeronyms</td><td>edu.smu.tspell.wordnet.NounSynset.getSubstanceMeronyms(): Array[edu.smu.tspell.wordnet.NounSynset]</td><td>Array[edu.smu.tspell.wordnet.NounSynset]</td><td>NounSynset:edu.smu.tspell.wordnet.NounSynset</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getTopicMembers</td><td>edu.smu.tspell.wordnet.NounSynset.getTopicMembers(): Array[edu.smu.tspell.wordnet.Synset]</td><td>Array[edu.smu.tspell.wordnet.Synset]</td><td>NounSynset:edu.smu.tspell.wordnet.NounSynset</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getTopics</td><td>edu.smu.tspell.wordnet.NounSynset.getTopics(): Array[edu.smu.tspell.wordnet.NounSynset]</td><td>Array[edu.smu.tspell.wordnet.NounSynset]</td><td>NounSynset:edu.smu.tspell.wordnet.NounSynset</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getUsageMembers</td><td>edu.smu.tspell.wordnet.NounSynset.getUsageMembers(): Array[edu.smu.tspell.wordnet.Synset]</td><td>Array[edu.smu.tspell.wordnet.Synset]</td><td>NounSynset:edu.smu.tspell.wordnet.NounSynset</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getUsages</td><td>edu.smu.tspell.wordnet.NounSynset.getUsages(): Array[edu.smu.tspell.wordnet.NounSynset]</td><td>Array[edu.smu.tspell.wordnet.NounSynset]</td><td>NounSynset:edu.smu.tspell.wordnet.NounSynset</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getAntonyms</td><td>edu.smu.tspell.wordnet.Synset.getAntonyms(x$1: java.lang.String): Array[edu.smu.tspell.wordnet.WordSense]</td><td>Array[edu.smu.tspell.wordnet.WordSense]</td><td>Synset:edu.smu.tspell.wordnet.Synset</td><td>x$1:java.lang.String</td><td></td></tr>
<tr><td>nlp</td><td>getDefinition</td><td>edu.smu.tspell.wordnet.Synset.getDefinition(): java.lang.String</td><td>String</td><td>Synset:edu.smu.tspell.wordnet.Synset</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getDerivationallyRelatedForms</td><td>edu.smu.tspell.wordnet.Synset.getDerivationallyRelatedForms(x$1: java.lang.String): Array[edu.smu.tspell.wordnet.WordSense]</td><td>Array[edu.smu.tspell.wordnet.WordSense]</td><td>Synset:edu.smu.tspell.wordnet.Synset</td><td>x$1:java.lang.String</td><td></td></tr>
<tr><td>nlp</td><td>getTagCount</td><td>edu.smu.tspell.wordnet.Synset.getTagCount(x$1: java.lang.String): Int</td><td>Int</td><td>Synset:edu.smu.tspell.wordnet.Synset</td><td>x$1:java.lang.String</td><td></td></tr>
<tr><td>nlp</td><td>getType</td><td>edu.smu.tspell.wordnet.Synset.getType(): edu.smu.tspell.wordnet.SynsetType</td><td>edu.smu.tspell.wordnet.SynsetType</td><td>Synset:edu.smu.tspell.wordnet.Synset</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getUsageExamples</td><td>edu.smu.tspell.wordnet.Synset.getUsageExamples(): Array[java.lang.String]</td><td>Array[java.lang.String]</td><td>Synset:edu.smu.tspell.wordnet.Synset</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getWordForms</td><td>edu.smu.tspell.wordnet.Synset.getWordForms(): Array[java.lang.String]</td><td>Array[java.lang.String]</td><td>Synset:edu.smu.tspell.wordnet.Synset</td><td></td><td></td></tr>
<tr><td>nlp</td><td>getCode</td><td>edu.smu.tspell.wordnet.SynsetType.getCode(): Int</td><td>Int</td><td>SynsetType:edu.smu.tspell.wordnet.SynsetType</td><td></td><td></td></tr>
<tr><td>nlp, collections</td><td>numericPairs</td><td>core.Solving.TextFunctions.numericPairs(text: core.nlp.SemanticWrapper): scala.collection.immutable.Vector[(Seq[String],Double)]</td><td>scala.collection.immutable.Vector[(Seq[String], Double)]</td><td>text:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>nlp, collections</td><td>prefixes</td><td>core.Solving.TextFunctions.prefixes(s: String): scala.collection.immutable.IndexedSeq[String]</td><td>scala.collection.immutable.IndexedSeq[String]</td><td>s:String</td><td></td><td></td></tr>
<tr><td>nlp, collections</td><td>slidingSubsets</td><td>core.Solving.TextFunctions.slidingSubsets(s: core.nlp.SemanticWrapper): Iterator[scala.collection.Set[String]]</td><td>Iterator[scala.collection.Set[String]]</td><td>s:core.nlp.SemanticWrapper</td><td></td><td></td></tr>
<tr><td>scala.Array</td><td>apply</td><td>scala.Array.apply(i: Int): T</td><td>T</td><td>Array:Array[T]</td><td>i:Int</td><td></td></tr>
<tr><td>scala.Array</td><td>length</td><td>scala.Array.length: Int</td><td>Int</td><td>Array:Array[T]</td><td></td><td></td></tr>
<tr><td>scala.Byte</td><td>$div</td><td>scala.Byte.$div(x: Byte): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Byte</td><td></td></tr>
<tr><td>scala.Byte</td><td>$div</td><td>scala.Byte.$div(x: Char): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Char</td><td></td></tr>
<tr><td>scala.Byte</td><td>$div</td><td>scala.Byte.$div(x: Double): Double</td><td>Double</td><td>Byte:Byte</td><td>x:Double</td><td></td></tr>
<tr><td>scala.Byte</td><td>$div</td><td>scala.Byte.$div(x: Int): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Int</td><td></td></tr>
<tr><td>scala.Byte</td><td>$div</td><td>scala.Byte.$div(x: Long): Long</td><td>Long</td><td>Byte:Byte</td><td>x:Long</td><td></td></tr>
<tr><td>scala.Byte</td><td>$minus</td><td>scala.Byte.$minus(x: Byte): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Byte</td><td></td></tr>
<tr><td>scala.Byte</td><td>$minus</td><td>scala.Byte.$minus(x: Char): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Char</td><td></td></tr>
<tr><td>scala.Byte</td><td>$minus</td><td>scala.Byte.$minus(x: Double): Double</td><td>Double</td><td>Byte:Byte</td><td>x:Double</td><td></td></tr>
<tr><td>scala.Byte</td><td>$minus</td><td>scala.Byte.$minus(x: Int): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Int</td><td></td></tr>
<tr><td>scala.Byte</td><td>$minus</td><td>scala.Byte.$minus(x: Long): Long</td><td>Long</td><td>Byte:Byte</td><td>x:Long</td><td></td></tr>
<tr><td>scala.Byte</td><td>$percent</td><td>scala.Byte.$percent(x: Byte): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Byte</td><td></td></tr>
<tr><td>scala.Byte</td><td>$percent</td><td>scala.Byte.$percent(x: Char): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Char</td><td></td></tr>
<tr><td>scala.Byte</td><td>$percent</td><td>scala.Byte.$percent(x: Double): Double</td><td>Double</td><td>Byte:Byte</td><td>x:Double</td><td></td></tr>
<tr><td>scala.Byte</td><td>$percent</td><td>scala.Byte.$percent(x: Int): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Int</td><td></td></tr>
<tr><td>scala.Byte</td><td>$percent</td><td>scala.Byte.$percent(x: Long): Long</td><td>Long</td><td>Byte:Byte</td><td>x:Long</td><td></td></tr>
<tr><td>scala.Byte</td><td>$plus</td><td>scala.Byte.$plus(x: Byte): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Byte</td><td></td></tr>
<tr><td>scala.Byte</td><td>$plus</td><td>scala.Byte.$plus(x: Char): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Char</td><td></td></tr>
<tr><td>scala.Byte</td><td>$plus</td><td>scala.Byte.$plus(x: Double): Double</td><td>Double</td><td>Byte:Byte</td><td>x:Double</td><td></td></tr>
<tr><td>scala.Byte</td><td>$plus</td><td>scala.Byte.$plus(x: Int): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Int</td><td></td></tr>
<tr><td>scala.Byte</td><td>$plus</td><td>scala.Byte.$plus(x: Long): Long</td><td>Long</td><td>Byte:Byte</td><td>x:Long</td><td></td></tr>
<tr><td>scala.Byte</td><td>$plus</td><td>scala.Byte.$plus(x: String): String</td><td>String</td><td>Byte:Byte</td><td>x:String</td><td></td></tr>
<tr><td>scala.Byte</td><td>$times</td><td>scala.Byte.$times(x: Byte): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Byte</td><td></td></tr>
<tr><td>scala.Byte</td><td>$times</td><td>scala.Byte.$times(x: Double): Double</td><td>Double</td><td>Byte:Byte</td><td>x:Double</td><td></td></tr>
<tr><td>scala.Byte</td><td>$times</td><td>scala.Byte.$times(x: Int): Int</td><td>Int</td><td>Byte:Byte</td><td>x:Int</td><td></td></tr>
<tr><td>scala.Byte</td><td>$times</td><td>scala.Byte.$times(x: Long): Long</td><td>Long</td><td>Byte:Byte</td><td>x:Long</td><td></td></tr>
<tr><td>scala.Byte</td><td>toChar</td><td>scala.Byte.toChar: Char</td><td>Char</td><td>Byte:Byte</td><td></td><td></td></tr>
<tr><td>scala.Byte</td><td>toDouble</td><td>scala.Byte.toDouble: Double</td><td>Double</td><td>Byte:Byte</td><td></td><td></td></tr>
<tr><td>scala.Byte</td><td>toInt</td><td>scala.Byte.toInt: Int</td><td>Int</td><td>Byte:Byte</td><td></td><td></td></tr>
<tr><td>scala.Byte</td><td>toLong</td><td>scala.Byte.toLong: Long</td><td>Long</td><td>Byte:Byte</td><td></td><td></td></tr>
<tr><td>scala.Byte</td><td>unary_$minus</td><td>scala.Byte.unary_$minus: Int</td><td>Int</td><td>Byte:Byte</td><td></td><td></td></tr>
<tr><td>scala.Byte</td><td>unary_$tilde</td><td>scala.Byte.unary_$tilde: Int</td><td>Int</td><td>Byte:Byte</td><td></td><td></td></tr>
<tr><td>scala.Char</td><td>$div</td><td>scala.Char.$div(x: Byte): Int</td><td>Int</td><td>Char:Char</td><td>x:Byte</td><td></td></tr>
<tr><td>scala.Char</td><td>$div</td><td>scala.Char.$div(x: Char): Int</td><td>Int</td><td>Char:Char</td><td>x:Char</td><td></td></tr>
<tr><td>scala.Char</td><td>$div</td><td>scala.Char.$div(x: Double): Double</td><td>Double</td><td>Char:Char</td><td>x:Double</td><td></td></tr>
<tr><td>scala.Char</td><td>$div</td><td>scala.Char.$div(x: Int): Int</td><td>Int</td><td>Char:Char</td><td>x:Int</td><td></td></tr>
<tr><td>scala.Char</td><td>$div</td><td>scala.Char.$div(x: Long): Long</td><td>Long</td><td>Char:Char</td><td>x:Long</td><td></td></tr>
<tr><td>scala.Char</td><td>$minus</td><td>scala.Char.$minus(x: Byte): Int</td><td>Int</td><td>Char:Char</td><td>x:Byte</td><td></td></tr>
<tr><td>scala.Char</td><td>$minus</td><td>scala.Char.$minus(x: Char): Int</td><td>Int</td><td>Char:Char</td><td>x:Char</td><td></td></tr>
<tr><td>scala.Char</td><td>$minus</td><td>scala.Char.$minus(x: Double): Double</td><td>Double</td><td>Char:Char</td><td>x:Double</td><td></td></tr>
<tr><td>scala.Char</td><td>$minus</td><td>scala.Char.$minus(x: Int): Int</td><td>Int</td><td>Char:Char</td><td>x:Int</td><td></td></tr>
<tr><td>scala.Char</td><td>$minus</td><td>scala.Char.$minus(x: Long): Long</td><td>Long</td><td>Char:Char</td><td>x:Long</td><td></td></tr>
<tr><td>scala.Char</td><td>$percent</td><td>scala.Char.$percent(x: Byte): Int</td><td>Int</td><td>Char:Char</td><td>x:Byte</td><td></td></tr>
<tr><td>scala.Char</td><td>$percent</td><td>scala.Char.$percent(x: Char): Int</td><td>Int</td><td>Char:Char</td><td>x:Char</td><td></td></tr>
<tr><td>scala.Char</td><td>$percent</td><td>scala.Char.$percent(x: Double): Double</td><td>Double</td><td>Char:Char</td><td>x:Double</td><td></td></tr>
<tr><td>scala.Char</td><td>$percent</td><td>scala.Char.$percent(x: Int): Int</td><td>Int</td><td>Char:Char</td><td>x:Int</td><td></td></tr>
<tr><td>scala.Char</td><td>$percent</td><td>scala.Char.$percent(x: Long): Long</td><td>Long</td><td>Char:Char</td><td>x:Long</td><td></td></tr>
<tr><td>scala.Char</td><td>$plus</td><td>scala.Char.$plus(x: Byte): Int</td><td>Int</td><td>Char:Char</td><td>x:Byte</td><td></td></tr>
<tr><td>scala.Char</td><td>$plus</td><td>scala.Char.$plus(x: Char): Int</td><td>Int</td><td>Char:Char</td><td>x:Char</td><td></td></tr>
<tr><td>scala.Char</td><td>$plus</td><td>scala.Char.$plus(x: Double): Double</td><td>Double</td><td>Char:Char</td><td>x:Double</td><td></td></tr>
<tr><td>scala.Char</td><td>$plus</td><td>scala.Char.$plus(x: Int): Int</td><td>Int</td><td>Char:Char</td><td>x:Int</td><td></td></tr>
<tr><td>scala.Char</td><td>$plus</td><td>scala.Char.$plus(x: Long): Long</td><td>Long</td><td>Char:Char</td><td>x:Long</td><td></td></tr>
<tr><td>scala.Char</td><td>$plus</td><td>scala.Char.$plus(x: String): String</td><td>String</td><td>Char:Char</td><td>x:String</td><td></td></tr>
<tr><td>scala.Char</td><td>$times</td><td>scala.Char.$times(x: Byte): Int</td><td>Int</td><td>Char:Char</td><td>x:Byte</td><td></td></tr>
<tr><td>scala.Char</td><td>$times</td><td>scala.Char.$times(x: Double): Double</td><td>Double</td><td>Char:Char</td><td>x:Double</td><td></td></tr>
<tr><td>scala.Char</td><td>$times</td><td>scala.Char.$times(x: Int): Int</td><td>Int</td><td>Char:Char</td><td>x:Int</td><td></td></tr>
<tr><td>scala.Char</td><td>$times</td><td>scala.Char.$times(x: Long): Long</td><td>Long</td><td>Char:Char</td><td>x:Long</td><td></td></tr>
<tr><td>scala.Char</td><td>toDouble</td><td>scala.Char.toDouble: Double</td><td>Double</td><td>Char:Char</td><td></td><td></td></tr>
<tr><td>scala.Char</td><td>toInt</td><td>scala.Char.toInt: Int</td><td>Int</td><td>Char:Char</td><td></td><td></td></tr>
<tr><td>scala.Char</td><td>toLong</td><td>scala.Char.toLong: Long</td><td>Long</td><td>Char:Char</td><td></td><td></td></tr>
<tr><td>scala.Char</td><td>unary_$minus</td><td>scala.Char.unary_$minus: Int</td><td>Int</td><td>Char:Char</td><td></td><td></td></tr>
<tr><td>scala.Char</td><td>unary_$tilde</td><td>scala.Char.unary_$tilde: Int</td><td>Int</td><td>Char:Char</td><td></td><td></td></tr>
<tr><td>scala.Option</td><td>contains</td><td>scala.Option.contains[A1&gt;:A](elem: A1): Boolean</td><td>Boolean</td><td>Option:Option[A]</td><td>elem:A1</td><td></td></tr>
<tr><td>scala.Option</td><td>get</td><td>scala.Option.get: A</td><td>A</td><td>Option:Option[A]</td><td></td><td></td></tr>
<tr><td>scala.Option</td><td>isDefined</td><td>scala.Option.isDefined: Boolean</td><td>Boolean</td><td>Option:Option[A]</td><td></td><td></td></tr>
<tr><td>scala.Option</td><td>isEmpty</td><td>scala.Option.isEmpty: Boolean</td><td>Boolean</td><td>Option:Option[A]</td><td></td><td></td></tr>
<tr><td>scala.Option</td><td>nonEmpty</td><td>scala.Option.nonEmpty: Boolean</td><td>Boolean</td><td>Option:Option[A]</td><td></td><td></td></tr>
<tr><td>scala.Option</td><td>toList</td><td>scala.Option.toList: List[A]</td><td>List[A]</td><td>Option:Option[A]</td><td></td><td></td></tr>
<tr><td>scala.Product</td><td>productArity</td><td>scala.Product.productArity: Int</td><td>Int</td><td>Product:Product</td><td></td><td></td></tr>
<tr><td>scala.Product</td><td>productElement</td><td>scala.Product.productElement(n: Int): Any</td><td>Any</td><td>Product:Product</td><td>n:Int</td><td></td></tr>
<tr><td>scala.Product</td><td>productIterator</td><td>scala.Product.productIterator: Iterator[Any]</td><td>Iterator[Any]</td><td>Product:Product</td><td></td><td></td></tr>
<tr><td>scala.Product2</td><td>_1</td><td>scala.Product2._1: T1</td><td>T1</td><td>Product2:Product2[T1,T2]</td><td></td><td></td></tr>
<tr><td>scala.Product2</td><td>_2</td><td>scala.Product2._2: T2</td><td>T2</td><td>Product2:Product2[T1,T2]</td><td></td><td></td></tr>
<tr><td>scala.Tuple2</td><td>apply</td><td>scala.Tuple2.apply[T1,T2](_1: T1,_2: T2): (T1,T2)</td><td>(T1, T2)</td><td>_1:T1</td><td>_2:T2</td><td></td></tr>
<tr><td>scala.Tuple2</td><td>swap</td><td>scala.Tuple2.swap=&gt;: (T2,T1)</td><td>(T2, T1)</td><td>Tuple2:(T1, T2)</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>asDigit</td><td>scala.runtime.RichChar.asDigit: Int</td><td>Int</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>getDirectionality</td><td>scala.runtime.RichChar.getDirectionality: Byte</td><td>Byte</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>getNumericValue</td><td>scala.runtime.RichChar.getNumericValue: Int</td><td>Int</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>isControl</td><td>scala.runtime.RichChar.isControl: Boolean</td><td>Boolean</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>isDigit</td><td>scala.runtime.RichChar.isDigit: Boolean</td><td>Boolean</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>isHighSurrogate</td><td>scala.runtime.RichChar.isHighSurrogate: Boolean</td><td>Boolean</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>isLetter</td><td>scala.runtime.RichChar.isLetter: Boolean</td><td>Boolean</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>isLetterOrDigit</td><td>scala.runtime.RichChar.isLetterOrDigit: Boolean</td><td>Boolean</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>isLowSurrogate</td><td>scala.runtime.RichChar.isLowSurrogate: Boolean</td><td>Boolean</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>isLower</td><td>scala.runtime.RichChar.isLower: Boolean</td><td>Boolean</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>isSpaceChar</td><td>scala.runtime.RichChar.isSpaceChar: Boolean</td><td>Boolean</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>isSurrogate</td><td>scala.runtime.RichChar.isSurrogate: Boolean</td><td>Boolean</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>isTitleCase</td><td>scala.runtime.RichChar.isTitleCase: Boolean</td><td>Boolean</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>isUnicodeIdentifierPart</td><td>scala.runtime.RichChar.isUnicodeIdentifierPart: Boolean</td><td>Boolean</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>isUnicodeIdentifierStart</td><td>scala.runtime.RichChar.isUnicodeIdentifierStart: Boolean</td><td>Boolean</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>isUpper</td><td>scala.runtime.RichChar.isUpper: Boolean</td><td>Boolean</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>isWhitespace</td><td>scala.runtime.RichChar.isWhitespace: Boolean</td><td>Boolean</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>max</td><td>scala.runtime.RichChar.max(that: Char): Char</td><td>Char</td><td>RichChar:scala.runtime.RichChar</td><td>that:Char</td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>min</td><td>scala.runtime.RichChar.min(that: Char): Char</td><td>Char</td><td>RichChar:scala.runtime.RichChar</td><td>that:Char</td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>reverseBytes</td><td>scala.runtime.RichChar.reverseBytes: Char</td><td>Char</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>self</td><td>scala.runtime.RichChar.self: Char</td><td>Char</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>toLower</td><td>scala.runtime.RichChar.toLower: Char</td><td>Char</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>toTitleCase</td><td>scala.runtime.RichChar.toTitleCase: Char</td><td>Char</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
<tr><td>scala.runtime.RichChar</td><td>toUpper</td><td>scala.runtime.RichChar.toUpper: Char</td><td>Char</td><td>RichChar:scala.runtime.RichChar</td><td></td><td></td></tr>
</tbody></table style='background-color: #FFF;'></body></html>